
<style>
  #info {
    position: fixed;
    bottom: 0;
    left: 0;
    width: 100%;
    max-height: 300px;
    background: #f9f9f9;
    border-top: 2px solid #ccc;
    transition: transform 0.3s ease-in-out;
    overflow-y: auto;
    z-index: 999;
  }
  #info.collapsed {
    transform: translateY(90%);
  }
  #toggle-info {
    position: fixed;
    bottom: 10px;
    right: 10px;
    background: #007bff;
    color: white;
    border: none;
    padding: 10px 15px;
    border-radius: 5px;
    z-index: 1000;
    cursor: pointer;
  }
</style>

<button id="toggle-info">Hide</button>
<div id="info"><!DOCTYPE html>
<html>
<head>
  <title>Live GPS Tracker v1.9 - Mobile</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.css" />
  <style>
    body, html { 
      margin: 0; 
      padding: 0; 
      height: 100%; 
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      overflow: hidden;
    }
    
    #map { 
      height: 100%; 
      width: 100%; 
      z-index: 0; 
    }

    /* Mobile-optimized info panel */
    #info {
      position: absolute;
      top: 10px;
      right: 10px;
      width: calc(100vw - 80px);
      max-width: 300px;
      max-height: 40vh;
      overflow-y: auto;
      background: rgba(255,255,255,0.95);
      padding: 8px;
      border-radius: 8px;
      font-size: 11px;
      color: #2C3E50;
      box-shadow: 0 2px 10px rgba(0,0,0,0.3);
      z-index: 1001;
      transition: transform 0.3s ease;
    }

    /* Collapsible info panel */
    #info.collapsed {
      transform: translateY(-90%);
    }
    
    #info-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 5px;
      cursor: pointer;
      user-select: none;
      min-height: 30px;
    }
    
    #toggle-info {
      background: #3498DB;
      color: white;
      border: none;
      border-radius: 6px;
      padding: 6px 12px;
      font-size: 12px;
      cursor: pointer;
      min-width: 50px;
      min-height: 30px;
      font-weight: bold;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
    }
    
    #toggle-info:active {
      background: #2980B9;
      transform: scale(0.95);
    }
    
    /* Ensure collapsed panel is still accessible */
    #info.collapsed #info-header {
      background: rgba(255,255,255,0.98);
      border-radius: 8px 8px 0 0;
      padding: 8px;
      margin: -8px -8px 5px -8px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    }

    /* Compact table for mobile */
    #device-table {
      width: 100%;
      font-size: 10px;
      border-collapse: collapse;
    }
    
    #device-table th,
    #device-table td {
      padding: 3px 2px;
      text-align: left;
      border-bottom: 1px solid #ddd;
    }
    
    #device-table th {
      background: #f5f5f5;
      font-weight: bold;
      position: sticky;
      top: 0;
    }

    /* Mobile-friendly controls */
    #controls {
      position: absolute;
      bottom: 10px;
      left: 10px;
      right: 10px;
      background: rgba(255,255,255,0.95);
      padding: 8px;
      border-radius: 8px;
      font-size: 11px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.3);
      z-index: 1001;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }

    #opacity-control {
      display: flex;
      align-items: center;
      gap: 5px;
      flex: 1;
      min-width: 120px;
    }

    #opacity-control input[type="range"] {
      flex: 1;
      min-width: 60px;
    }

    /* Status indicators */
    #status {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 10px;
    }

    .status-item {
      display: flex;
      align-items: center;
      gap: 2px;
    }

    /* Row styling */
    .row-active { background-color: #D5F5E3; }
    .row-warm   { background-color: #FCF3CF; }
    .row-stale  { background-color: #FADBD8; }

    .row-low-sats {
      background-color: #F5B7B1 !important;
      animation: blink 1s step-start infinite;
    }

    @keyframes blink {
      50% { background-color: #FADBD8; }
    }

    @keyframes pulse {
      0%   { background-color: #D5F5E3; }
      50%  { background-color: #ABEBC6; }
      100% { background-color: #D5F5E3; }
    }

    .row-active {
      animation: pulse 2s infinite;
    }

    /* Device labels - smaller for mobile */
    .device-label {
      background: transparent;
      color: #154360;
      font-weight: bold;
      text-align: center;
      line-height: 20px;
      font-size: 9px;
    }

    .arrow-icon {
      font-weight: bold;
      font-size: 16px;
    }

    /* Touch-friendly layer control */
    .leaflet-control-layers {
      background: rgba(255,255,255,0.95) !important;
      border-radius: 8px !important;
      box-shadow: 0 2px 10px rgba(0,0,0,0.3) !important;
    }
    
    .leaflet-control-layers label {
      font-size: 12px !important;
      padding: 6px !important;
    }

    /* Hide elements on very small screens */
    @media (max-width: 360px) {
      #info {
        width: calc(100vw - 40px);
        max-width: none;
        left: 10px;
        right: 10px;
      }
      
      #device-table th:nth-child(2),
      #device-table td:nth-child(2),
      #device-table th:nth-child(3),
      #device-table td:nth-child(3) {
        display: none;
      }
    }

    /* Portrait orientation adjustments */
    @media (orientation: portrait) and (max-height: 600px) {
      #info {
        max-height: 35vh;
      }
    }

    /* Landscape orientation adjustments */
    @media (orientation: landscape) and (max-height: 500px) {
      #info {
        max-height: 50vh;
        top: 5px;
        right: 5px;
        padding: 6px;
      }
      
      #controls {
        bottom: 5px;
        left: 5px;
        right: 5px;
        padding: 6px;
      }
    }
    
  </style>
</head>
<body>
  <div id="map"></div>
  
  <div id="info">
    <div id="info-header">
      <strong>üì° GPS Data</strong>
      <button id="toggle-info">Hide</button>
    </div>
    <div id="info-content">
      <table id="device-table">
        <thead>
          <tr>
            <th>ID</th>
            <th>Lat</th>
            <th>Lon</th>
            <th>Cnt</th>
            <th>Sat</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
  </div>
  
  <div id="controls">
    <div id="opacity-control">
      <label for="opacity-slider">Opacity:</label>
      <input type="range" id="opacity-slider" min="0.1" max="1" step="0.1" value="1">
      <span id="opacity-value">100%</span>
    </div>
    
    <div id="status">
      <div class="status-item">
        <span>üì∂</span>
        <span id="socket-status">‚ùå</span>
      </div>
      <div class="status-item">
        <span>üì±</span>
        <span id="device-count">0</span>
      </div>
      <div class="status-item">
        <span>üìç</span>
        <span id="point-count">0</span>
      </div>
      <div class="status-item">
        <span>üîç</span>
        <span id="current-zoom">13</span>
      </div>
    </div>
  </div>
  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.2/socket.io.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/esri-leaflet/3.0.12/esri-leaflet.min.js"></script>
  <script>
    // Wait for all libraries to load before initializing
    function initializeApp() {
      console.log('Checking libraries...');
      console.log('Leaflet (L):', typeof L);
      console.log('Socket.IO (io):', typeof io);
      
      if (typeof L === 'undefined') {
        console.error('Leaflet not loaded, retrying in 1000ms...');
        setTimeout(initializeApp, 1000);
        return;
      }
      
      if (typeof io === 'undefined') {
        console.error('Socket.IO not loaded, retrying in 1000ms...');
        setTimeout(initializeApp, 1000);
        return;
      }
      
      // Check if esri-leaflet is available (optional, won't block initialization)
      if (typeof L.esri === 'undefined') {
        console.warn('‚ö†Ô∏è Esri-Leaflet not loaded, will use basic layers only');
      }
      
      console.log('‚úÖ All required libraries loaded successfully');
      startGPSTracker();
    }
    
    function startGPSTracker() {
      // Initialize map with mobile optimizations
      const map = L.map("map", {
        maxZoom: 22,
        zoomControl: false, // We'll add it back in a better position
        tap: true,
        touchZoom: true,
        dragging: true
      }).setView([-32.758, 151.174], 13);
    
    // Add zoom control in better position for mobile
    L.control.zoom({
      position: 'topleft'
    }).addTo(map);

    // Base layers with increased maxZoom and maxNativeZoom
    const osmLayer = L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      maxZoom: 22,
      maxNativeZoom: 19,
      attribution: "¬© OpenStreetMap"
    });

    let nswTopoLayer, nswImageryLayer;
    
    // Try to create Esri layers if available, fallback to OSM
    if (typeof L.esri !== 'undefined') {
      try {
        nswTopoLayer = L.esri.tiledMapLayer({
          url: 'https://maps.six.nsw.gov.au/arcgis/rest/services/public/NSW_Topo_Map/MapServer',
          attribution: '¬© NSW Spatial Services',
          maxZoom: 22,
          maxNativeZoom: 16,
          opacity: 1
        });

        nswImageryLayer = L.esri.tiledMapLayer({
          url: 'https://maps.six.nsw.gov.au/arcgis/rest/services/public/NSW_Imagery/MapServer',
          attribution: '¬© NSW Spatial Services',
          maxZoom: 22,
          maxNativeZoom: 18,
          opacity: 1
        });
        console.log('‚úÖ NSW Esri layers created successfully');
      } catch (error) {
        console.warn('‚ö†Ô∏è Failed to create NSW Esri layers:', error);
        nswTopoLayer = osmLayer;
        nswImageryLayer = osmLayer;
      }
    } else {
      console.warn('‚ö†Ô∏è Esri-Leaflet not available, using OSM as fallback');
      nswTopoLayer = osmLayer;
      nswImageryLayer = osmLayer;
    }

    const worldImageryGoogle = L.tileLayer('https://mt1.google.com/vt/lyrs=s&x={x}&y={y}&z={z}', {
      attribution: '¬© Google',
      maxZoom: 22,
      maxNativeZoom: 20
    });

    // Add default layer (try NSW Topo, fallback to OSM)
    const defaultLayer = nswTopoLayer || osmLayer;
    defaultLayer.addTo(map);
    let currentBaseLayer = defaultLayer;

    // Layer control with available maps
    const baseLayers = {};
    
    if (nswTopoLayer && nswTopoLayer !== osmLayer) {
      baseLayers["NSW Topo"] = nswTopoLayer;
    }
    if (nswImageryLayer && nswImageryLayer !== osmLayer) {
      baseLayers["NSW Imagery"] = nswImageryLayer;
    }
    baseLayers["Google Satellite"] = worldImageryGoogle;
    baseLayers["OpenStreetMap"] = osmLayer;

    const layerControl = L.control.layers(baseLayers, null, {
      position: 'topleft',
      collapsed: true
    }).addTo(map);

    // Mobile-specific event handlers
    const infoPanel = document.getElementById('info');
    const toggleButton = document.getElementById('toggle-info');
    const infoContent = document.getElementById('info-content');
    
    toggleButton.addEventListener('click', function(e) {
      e.preventDefault();
      e.stopPropagation();
      infoPanel.classList.toggle('collapsed');
      toggleButton.textContent = infoPanel.classList.contains('collapsed') ? 'Show' : 'Hide';
    });
    
    // Also allow clicking the header to toggle
    document.getElementById('info-header').addEventListener('click', function(e) {
      if (e.target === toggleButton) return; // Don't double-trigger
      infoPanel.classList.toggle('collapsed');
      toggleButton.textContent = infoPanel.classList.contains('collapsed') ? 'Show' : 'Hide';
    });
    
    // Auto-collapse on small screens
    if (window.innerWidth < 400) {
      infoPanel.classList.add('collapsed');
      toggleButton.textContent = 'Show';
    }

    // Update zoom display
    const currentZoomSpan = document.getElementById('current-zoom');
    map.on('zoomend', function() {
      currentZoomSpan.textContent = map.getZoom();
    });

    // Opacity control
    const opacitySlider = document.getElementById('opacity-slider');
    const opacityValue = document.getElementById('opacity-value');

    opacitySlider.addEventListener('input', function() {
      const opacity = parseFloat(this.value);
      currentBaseLayer.setOpacity(opacity);
      opacityValue.textContent = Math.round(opacity * 100) + '%';
    });

    // Update current base layer when user switches
    map.on('baselayerchange', function(e) {
      currentBaseLayer = e.layer;
      const opacity = parseFloat(opacitySlider.value);
      currentBaseLayer.setOpacity(opacity);
    });

    // Device colors - expanded for 15 devices
    const deviceColors = {
      '1': '#E74C3C', '2': '#3498DB', '3': '#2ECC71', '4': '#F39C12', '5': '#9B59B6',
      '6': '#1ABC9C', '7': '#E67E22', '8': '#34495E', '9': '#E91E63', '10': '#FF5722',
      '11': '#795548', '12': '#607D8B', '13': '#FF9800', '14': '#4CAF50', '15': '#673AB7',
      'I': '#E74C3C', 'II': '#3498DB', 'III': '#2ECC71', 'IV': '#F39C12', 'V': '#9B59B6',
      'VI': '#1ABC9C', 'VII': '#E67E22', 'VIII': '#34495E', 'IX': '#E91E63', 'X': '#FF5722',
      'XI': '#795548', 'XII': '#607D8B', 'XIII': '#FF9800', 'XIV': '#4CAF50', 'XV': '#673AB7'
    };

    // Initialize socket connection with better error handling
    const socket = io({ 
      transports: ['websocket'],
      timeout: 5000,
      forceNew: true,
      autoConnect: false  // Don't auto-connect, we'll handle this manually
    });
    
    // Status elements
    const socketStatus = document.getElementById('socket-status');
    const deviceCount = document.getElementById('device-count');
    const pointCount = document.getElementById('point-count');
    
    let totalPoints = 0;
    let isTestMode = false;
    let connectionAttempts = 0;
    const maxConnectionAttempts = 3;

    // Try to connect to server
    function attemptConnection() {
      if (connectionAttempts >= maxConnectionAttempts) {
        console.log('üîÑ Max connection attempts reached, switching to test mode');
        enableTestMode();
        return;
      }
      
      connectionAttempts++;
      console.log(`üîå Attempting server connection (${connectionAttempts}/${maxConnectionAttempts})`);
      socket.connect();
      
      // If connection fails after 3 seconds, try again or switch to test mode
      setTimeout(() => {
        if (!socket.connected) {
          console.log(`‚ùå Connection attempt ${connectionAttempts} failed`);
          if (connectionAttempts < maxConnectionAttempts) {
            attemptConnection();
          } else {
            enableTestMode();
          }
        }
      }, 3000);
    }
    
    function enableTestMode() {
      isTestMode = true;
      socketStatus.textContent = 'üß™';
      socketStatus.style.color = '#FF9800';
      socketStatus.title = 'Test Mode - No server connection';
      
      console.log('üß™ Enabled test mode - generating sample GPS data');
      
      // Add a notice to the info panel
      const infoContent = document.getElementById('info-content');
      const testNotice = document.createElement('div');
      testNotice.style.cssText = 'background: #fff3cd; border: 1px solid #ffeaa7; padding: 4px; margin-bottom: 5px; font-size: 9px; border-radius: 4px; text-align: center;';
      testNotice.innerHTML = 'üß™ <strong>Test Mode</strong><br>Displaying sample data';
      infoContent.insertBefore(testNotice, infoContent.firstChild);
      
      // Start generating test data immediately
      generateTestData();
      setInterval(generateTestData, 5000);
    }

    // Socket connection handlers
    socket.on('connect', () => {
      console.log('‚úÖ Socket connected to server');
      socketStatus.textContent = '‚úÖ';
      socketStatus.style.color = '#2ECC71';
      socketStatus.title = 'Connected to GPS server';
      connectionAttempts = 0;
      isTestMode = false;
    });

    socket.on('disconnect', () => {
      console.log('‚ùå Socket disconnected from server');
      socketStatus.textContent = '‚ùå';
      socketStatus.style.color = '#E74C3C';
      socketStatus.title = 'Disconnected from GPS server';
      
      // Try to reconnect after a delay
      setTimeout(() => {
        if (!isTestMode) {
          attemptConnection();
        }
      }, 2000);
    });

    socket.on('connect_error', (error) => {
      console.log(`‚ö†Ô∏è Socket connection error (attempt ${connectionAttempts}):`, error.message);
      socketStatus.textContent = '‚ö†Ô∏è';
      socketStatus.style.color = '#F39C12';
      socketStatus.title = 'Connection error - trying to connect...';
    });

    const gpsTrails = {};
    const packetCounts = {};
    const latestPackets = {};
    const allPointsBounds = L.latLngBounds();
    const allMarkers = {};
    const trailLayers = {};
    const deviceVisibility = {};
    let selectedDevice = null;
    let hasInitialData = false;

    function toggleDeviceVisibility(deviceId) {
      if (selectedDevice === deviceId) {
        selectedDevice = null;
        showAllDevices();
      } else {
        selectedDevice = deviceId;
        hideAllDevicesExcept(deviceId);
      }
    }

    function showAllDevices() {
      Object.keys(allMarkers).forEach(deviceId => {
        deviceVisibility[deviceId] = true;
        showDeviceMarkers(deviceId);
      });
    }

    function hideAllDevicesExcept(keepDeviceId) {
      Object.keys(allMarkers).forEach(deviceId => {
        if (deviceId === keepDeviceId) {
          deviceVisibility[deviceId] = true;
          showDeviceMarkers(deviceId);
        } else {
          deviceVisibility[deviceId] = false;
          hideDeviceMarkers(deviceId);
        }
      });
    }

    function showDeviceMarkers(deviceId) {
      if (allMarkers[deviceId] && allMarkers[deviceId].current) {
        allMarkers[deviceId].current.circle.addTo(map);
        allMarkers[deviceId].current.label.addTo(map);
      }
      
      if (allMarkers[deviceId] && allMarkers[deviceId].history) {
        allMarkers[deviceId].history.forEach(marker => {
          marker.addTo(map);
        });
      }
      
      if (trailLayers[deviceId]) {
        trailLayers[deviceId].forEach(layer => {
          layer.addTo(map);
        });
      }
    }

    function hideDeviceMarkers(deviceId) {
      if (allMarkers[deviceId] && allMarkers[deviceId].current) {
        map.removeLayer(allMarkers[deviceId].current.circle);
        map.removeLayer(allMarkers[deviceId].current.label);
      }
      
      if (allMarkers[deviceId] && allMarkers[deviceId].history) {
        allMarkers[deviceId].history.forEach(marker => {
          map.removeLayer(marker);
        });
      }
      
      if (trailLayers[deviceId]) {
        trailLayers[deviceId].forEach(layer => {
          map.removeLayer(layer);
        });
      }
    }

    function addDataPoint(point, isLatest = false) {
      const lat = parseFloat(point.latitude);
      const lon = parseFloat(point.longitude);
      
      if (isNaN(lat) || isNaN(lon) || lat < -90 || lat > 90 || lon < -180 || lon > 180) {
        console.warn('Invalid coordinates:', point);
        return;
      }

      const color = deviceColors[point.device_id] || "#7F8C8D";

      if (isLatest) {
        const circle = L.circleMarker([lat, lon], {
          radius: 10, // Slightly smaller for mobile
          color: color,
          fillColor: color,
          fillOpacity: 0.9,
          weight: 2
        });

        const popupContent = `
          <strong>Device:</strong> ${point.device_id}<br>
          <strong>Location:</strong> ${lat.toFixed(4)}, ${lon.toFixed(4)}<br>
          <strong>Time:</strong> ${new Date(point.timestamp).toLocaleTimeString()}<br>
          <strong>Satellites:</strong> ${point.sats || 'N/A'}
        `;
        circle.bindPopup(popupContent);

        const label = L.divIcon({
          html: `<div style="color: ${color}; font-weight: bold; text-shadow: 1px 1px 2px white;">${point.device_id}</div>`,
          className: 'device-label',
          iconSize: [20, 20]
        });

        const labelMarker = L.marker([lat, lon], { icon: label, interactive: false });
        
        if (!allMarkers[point.device_id]) allMarkers[point.device_id] = { current: null, history: [] };
        
        if (allMarkers[point.device_id].current) {
          map.removeLayer(allMarkers[point.device_id].current.circle);
          map.removeLayer(allMarkers[point.device_id].current.label);
        }
        
        allMarkers[point.device_id].current = { circle, label: labelMarker };
        
        if (deviceVisibility[point.device_id] !== false) {
          circle.addTo(map);
          labelMarker.addTo(map);
        }
        
        totalPoints++;
        
      } else {
        const isFirstPoint = !allMarkers[point.device_id] || allMarkers[point.device_id].history.length === 0;
        
        if (isFirstPoint) {
          const triangleIcon = L.divIcon({
            html: `<div style="
              width: 0; 
              height: 0; 
              border-left: 10px solid transparent;
              border-right: 10px solid transparent;
              border-bottom: 16px solid ${color};
              filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
            "></div>`,
            className: 'start-triangle',
            iconSize: [16, 14],
            iconAnchor: [10, 16]
          });

          const triangle = L.marker([lat, lon], { 
            icon: triangleIcon,
            interactive: true
          });

          const popupContent = `
            <strong>Start:</strong> ${point.device_id}<br>
            <strong>Location:</strong> ${lat.toFixed(4)}, ${lon.toFixed(4)}<br>
            <strong>Time:</strong> ${new Date(point.timestamp).toLocaleTimeString()}
          `;
          triangle.bindPopup(popupContent);

          if (!allMarkers[point.device_id]) allMarkers[point.device_id] = { current: null, history: [] };
          allMarkers[point.device_id].history.push(triangle);
          
          if (deviceVisibility[point.device_id] !== false) {
            triangle.addTo(map);
          }
          
          totalPoints++;
        } else {
          const pinIcon = L.divIcon({
            html: `<div style="
              width: 5px; 
              height: 5px; 
              background-color: ${color}; 
              border: 1px solid white; 
              border-radius: 50%;
              box-shadow: 0 0 2px rgba(0,0,0,0.3);
            "></div>`,
            className: 'history-pin',
            iconSize: [5, 5],
            iconAnchor: [2.5, 2.5]
          });

          const pin = L.marker([lat, lon], { 
            icon: pinIcon,
            interactive: true
          });

          const popupContent = `
            <strong>Device:</strong> ${point.device_id}<br>
            <strong>Location:</strong> ${lat.toFixed(4)}, ${lon.toFixed(4)}<br>
            <strong>Time:</strong> ${new Date(point.timestamp).toLocaleTimeString()}
          `;
          pin.bindPopup(popupContent);

          if (!allMarkers[point.device_id]) allMarkers[point.device_id] = { current: null, history: [] };
          allMarkers[point.device_id].history.push(pin);
          
          if (deviceVisibility[point.device_id] !== false) {
            pin.addTo(map);
          }
          
          totalPoints++;
        }
      }
    }

    function calculateBearing(lat1, lon1, lat2, lon2) {
      const dLon = (lon2 - lon1) * Math.PI / 180;
      const lat1Rad = lat1 * Math.PI / 180;
      const lat2Rad = lat2 * Math.PI / 180;
      
      const y = Math.sin(dLon) * Math.cos(lat2Rad);
      const x = Math.cos(lat1Rad) * Math.sin(lat2Rad) - Math.sin(lat1Rad) * Math.cos(lat2Rad) * Math.cos(dLon);
      
      const bearing = Math.atan2(y, x) * 180 / Math.PI;
      return (bearing + 360) % 360;
    }

    function addArrowToSegment(p1, p2, color) {
      const midLat = (p1[0] + p2[0]) / 2;
      const midLon = (p1[1] + p2[1]) / 2;
      
      const bearing = calculateBearing(p1[0], p1[1], p2[0], p2[1]);
      
      const arrowSvg = `
        <svg width="24" height="24" viewBox="0 0 16 16">
          <g transform="scale(1.5) translate(-4, -4) rotate(${bearing} 8 8)">
            <polygon 
              points="8,2 12,10 8,8 4,10" 
              fill="${color}" 
              stroke="white" 
              stroke-width="0.5" 
            />
          </g>
        </svg>
      `;

      const arrowIcon = L.divIcon({
        html: arrowSvg,
        className: 'arrow-icon',
        iconSize: [20, 16],
        iconAnchor: [12, 12]
      });

      return L.marker([midLat, midLon], { icon: arrowIcon, interactive: false });
    }

    function drawTrail(device_id) {
      const trail = gpsTrails[device_id];
      if (!trail || trail.length < 2) return;
      
      const color = deviceColors[device_id] || "#7F8C8D";

      if (trailLayers[device_id]) {
        trailLayers[device_id].forEach(layer => {
          if (map.hasLayer(layer)) {
            map.removeLayer(layer);
          }
        });
      }
      trailLayers[device_id] = [];

      const polyline = L.polyline(trail, {
        color: color,
        weight: 2, // Thinner for mobile
        opacity: 0.7
      });
      
      trailLayers[device_id].push(polyline);
      
      if (deviceVisibility[device_id] !== false) {
        polyline.addTo(map);
      }

      // Fewer arrows for mobile performance
      const numArrows = Math.min(trail.length - 1, 5);
      const step = Math.max(1, Math.floor((trail.length - 1) / numArrows));
      
      for (let i = step; i < trail.length; i += step) {
        const arrow = addArrowToSegment(trail[i-1], trail[i], color);
        trailLayers[device_id].push(arrow);
        
        if (deviceVisibility[device_id] !== false) {
          arrow.addTo(map);
        }
      }
    }

    function getRowClass(ts, sats) {
      const pingTime = new Date(ts);
      const now = new Date();
      const diff = (now - pingTime) / 1000;

      if (sats !== undefined && sats < 4) return "row-low-sats";

      if (diff <= 180) return "row-active";
      if (diff <= 360) return "row-warm";
      return "row-stale";
    }

    function updateTable() {
      const tbody = document.querySelector("#device-table tbody");
      tbody.innerHTML = "";

      const sortedIDs = Object.keys(latestPackets).sort((a, b) =>
        a.localeCompare(b, 'en', { sensitivity: 'base', numeric: true })
      );

      for (const id of sortedIDs) {
        const packet = latestPackets[id];
        const count = packetCounts[id] || 0;
        const sats = packet.sats ?? "‚Äî";
        const lat = parseFloat(packet.latitude).toFixed(4);
        const lon = parseFloat(packet.longitude).toFixed(4);

        const row = document.createElement("tr");
        row.className = getRowClass(packet.timestamp, packet.sats);

        row.innerHTML = `
          <td>${id}</td>
          <td>${lat}</td>
          <td>${lon}</td>
          <td>${count}</td>
          <td>${sats}</td>
        `;

        row.style.cursor = "pointer";
        row.addEventListener('click', () => {
          toggleDeviceVisibility(id);
          updateTable();
        });
        
        // Add touch feedback
        row.addEventListener('touchstart', () => {
          row.style.backgroundColor = '#e3f2fd';
        });
        
        row.addEventListener('touchend', () => {
          setTimeout(() => {
            row.className = getRowClass(packet.timestamp, packet.sats);
          }, 200);
        });

        if (selectedDevice === id) {
          row.style.border = "2px solid #3498DB";
        }

        tbody.appendChild(row);
      }
    }

    function updateStatusInfo() {
      deviceCount.textContent = Object.keys(latestPackets).length;
      pointCount.textContent = totalPoints;
    }
    
    socket.on("gps_update", (data) => {
      console.log('üì° Received GPS update:', data);
      
      const { latitude, longitude, device_id, timestamp } = data;
      if (!latitude || !longitude || !device_id || !timestamp) {
        console.warn('Missing required data:', data);
        return;
      }

      const lat = parseFloat(latitude);
      const lon = parseFloat(longitude);
      
      if (isNaN(lat) || isNaN(lon)) {
        console.warn('Invalid coordinates:', data);
        return;
      }

      latestPackets[device_id] = {
        ...data,
        timestamp: timestamp.replace(" ", "T") + "Z"
      };

      packetCounts[device_id] = (packetCounts[device_id] || 0) + 1;

      if (gpsTrails[device_id] && gpsTrails[device_id].length) {
        const lastPoint = {
          ...latestPackets[device_id],
          latitude: gpsTrails[device_id][gpsTrails[device_id].length - 1][0],
          longitude: gpsTrails[device_id][gpsTrails[device_id].length - 1][1]
        };
        addDataPoint(lastPoint, false);
      }
      
      addDataPoint(data, true);
      allPointsBounds.extend([lat, lon]);
      
      if (!hasInitialData) {
        map.fitBounds(allPointsBounds, { padding: [30, 30], maxZoom: 16 });
        hasInitialData = true;
      }

      gpsTrails[device_id] = gpsTrails[device_id] || [];
      gpsTrails[device_id].push([lat, lon]);
      if (gpsTrails[device_id].length > 50) gpsTrails[device_id].shift(); // Shorter trails for mobile

      drawTrail(device_id);
      updateTable();
      updateStatusInfo();
    });

    // Test data generator with more realistic movement
    function generateTestData() {
      const testDevices = ['I', 'II', 'III', 'IV', 'V'];
      const baseLat = -32.758;
      const baseLon = 151.174;
      
      testDevices.forEach((deviceId, index) => {
        // Create persistent movement for each device
        if (!window.devicePositions) window.devicePositions = {};
        
        if (!window.devicePositions[deviceId]) {
          // Initial position with some spread
          window.devicePositions[deviceId] = {
            lat: baseLat + (index - 2) * 0.002 + (Math.random() - 0.5) * 0.001,
            lon: baseLon + (index - 2) * 0.002 + (Math.random() - 0.5) * 0.001,
            bearing: Math.random() * 360,
            speed: 0.0001 + Math.random() * 0.0001
          };
        }
        
        const device = window.devicePositions[deviceId];
        
        // Slight course corrections
        device.bearing += (Math.random() - 0.5) * 30;
        device.speed = Math.max(0.00005, Math.min(0.0002, device.speed + (Math.random() - 0.5) * 0.00005));
        
        // Move in current direction
        const radians = device.bearing * Math.PI / 180;
        device.lat += Math.cos(radians) * device.speed;
        device.lon += Math.sin(radians) * device.speed;
        
        // Keep within reasonable bounds
        const maxDistance = 0.01;
        if (Math.abs(device.lat - baseLat) > maxDistance) {
          device.bearing = (device.bearing + 180) % 360;
        }
        if (Math.abs(device.lon - baseLon) > maxDistance) {
          device.bearing = (device.bearing + 180) % 360;
        }
        
        const testData = {
          device_id: deviceId,
          latitude: device.lat.toFixed(6),
          longitude: device.lon.toFixed(6),
          timestamp: new Date().toISOString().replace('T', ' ').replace('Z', ''),
          sats: Math.floor(Math.random() * 8) + 4 + (Math.random() < 0.1 ? -2 : 0) // Occasional low satellite count
        };
        
        // Simulate receiving data
        handleGpsUpdate(testData);
      });
    }
    
    // Unified GPS update handler (works for both real and test data)
    function handleGpsUpdate(data) {
      console.log('üì° Processing GPS update:', data);
      
      const { latitude, longitude, device_id, timestamp } = data;
      if (!latitude || !longitude || !device_id || !timestamp) {
        console.warn('Missing required data:', data);
        return;
      }

      const lat = parseFloat(latitude);
      const lon = parseFloat(longitude);
      
      if (isNaN(lat) || isNaN(lon)) {
        console.warn('Invalid coordinates:', data);
        return;
      }

      latestPackets[device_id] = {
        ...data,
        timestamp: timestamp.replace(" ", "T") + "Z"
      };

      packetCounts[device_id] = (packetCounts[device_id] || 0) + 1;

      if (gpsTrails[device_id] && gpsTrails[device_id].length) {
        const lastPoint = {
          ...latestPackets[device_id],
          latitude: gpsTrails[device_id][gpsTrails[device_id].length - 1][0],
          longitude: gpsTrails[device_id][gpsTrails[device_id].length - 1][1]
        };
        addDataPoint(lastPoint, false);
      }
      
      addDataPoint(data, true);
      allPointsBounds.extend([lat, lon]);
      
      if (!hasInitialData) {
        map.fitBounds(allPointsBounds, { padding: [30, 30], maxZoom: 16 });
        hasInitialData = true;
      }

      gpsTrails[device_id] = gpsTrails[device_id] || [];
      gpsTrails[device_id].push([lat, lon]);
      if (gpsTrails[device_id].length > 50) gpsTrails[device_id].shift(); // Shorter trails for mobile

      drawTrail(device_id);
      updateTable();
      updateStatusInfo();
    }

    // Uncomment the line below to generate test data every 5 seconds
    // setInterval(generateTestData, 5000);

    // Update table less frequently to save battery
    setInterval(updateTable, 15000);
    
    // Handle orientation changes
    window.addEventListener('orientationchange', function() {
      setTimeout(function() {
        map.invalidateSize();
      }, 100);
    });
    
    // Handle window resize
    window.addEventListener('resize', function() {
      map.invalidateSize();
    });
    
    } // End of startGPSTracker function
    
    // Initialize when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initializeApp);
    } else {
      initializeApp();
    }
  </script>
</body>
</html></div>
<script>
  document.addEventListener("DOMContentLoaded", function() {
    const infoPanel = document.getElementById('info');
    const toggleButton = document.getElementById('toggle-info');

    toggleButton.addEventListener('click', function(e) {
      e.preventDefault();
      e.stopPropagation();
      infoPanel.classList.toggle('collapsed');
      toggleButton.textContent = infoPanel.classList.contains('collapsed') ? 'Show' : 'Hide';
    });

    if (window.innerWidth < 400) {
      infoPanel.classList.add('collapsed');
      toggleButton.textContent = 'Show';
    }
  });
</script>
