<!DOCTYPE html>
<html>
<head>
  <title>Live GPS Tracker v1.9 - NSW Topo + World Imagery</title>
  <meta charset="utf-8" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <style>
    body, html { margin: 0; padding: 0; height: 100%; }
    #map { height: 100%; width: 100%; z-index: 0; }

    #info {
      position: absolute;
      top: 10px;
      right: 10px;
      max-width: 340px;
      max-height: 70%;
      overflow-y: auto;
      background: rgba(255,255,255,0.85);
      padding: 10px;
      border-radius: 8px;
      font-family: sans-serif;
      font-size: 13px;
      color: #2C3E50;
      box-shadow: 0 0 6px rgba(0,0,0,0.2);
      z-index: 1001;
    }

    #info2 {
      position: absolute;
      top: 10px;
      right: 370px;
      max-width: 340px;
      max-height: 70%;
      overflow-y: auto;
      background: rgba(255,255,255,0.85);
      padding: 10px;
      border-radius: 8px;
      font-family: sans-serif;
      font-size: 13px;
      color: #2C3E50;
      box-shadow: 0 0 6px rgba(0,0,0,0.2);
      z-index: 1001;
    }

    #toggle-button, #toggle-button2, #toggle-trails1, #toggle-trails2 {
      background-color: #0078D7;
      color: white;
      border: none;
      padding: 8px 16px;
      font-size: 14px;
      border-radius: 4px;
      cursor: pointer;
      margin-bottom: 10px;
      width: 100%;
    }
    
    #toggle-button:hover, #toggle-button2:hover, #toggle-trails1:hover, #toggle-trails2:hover {
      background-color: #005A9E;
    }

    #toggle-trails1, #toggle-trails2 {
      background-color: #28a745;
      margin-bottom: 5px;
      display: block !important;
      visibility: visible !important;
    }

    #toggle-trails1:hover, #toggle-trails2:hover {
      background-color: #218838;
    }

    #toggle-trails1.hidden-trails, #toggle-trails2.hidden-trails {
      background-color: #dc3545;
    }

    #toggle-trails1.hidden-trails:hover, #toggle-trails2.hidden-trails:hover {
      background-color: #c82333;
    }

    #opacity-control {
      position: absolute;
      bottom: 60px;
      left: 10px;
      background: rgba(255,255,255,0.9);
      padding: 10px;
      border-radius: 6px;
      font-family: sans-serif;
      font-size: 12px;
      box-shadow: 0 0 6px rgba(0,0,0,0.2);
      z-index: 1001;
    }

    #opacity-control label {
      display: block;
      margin-bottom: 5px;
      font-weight: bold;
    }

    #opacity-control input[type="range"] {
      width: 150px;
      margin-right: 10px;
    }

    .row-active { background-color: #D5F5E3; }
    .row-warm   { background-color: #FCF3CF; }
    .row-stale  { background-color: #FADBD8; }

    .row-low-sats {
      background-color: #F5B7B1 !important;
      animation: blink 1s step-start infinite;
    }

    @keyframes blink {
      50% { background-color: #FADBD8; }
    }

    .device-label {
      background: transparent;
      color: black;
      font-weight: bold;
      text-align: center;
      line-height: 24px;
      font-size: 11px;
    }

    .arrow-icon {
      font-weight: bold;
      font-size: 8px;
    }

    /* Animated dots and arrows on polyline */
    .animated-polyline {
      stroke-dasharray: 1, 14;
      stroke-linecap: round;
      animation: moveDots 4s linear infinite;
    }

    .animated-arrow {
      animation: moveArrow 4s linear infinite;
    }

    @keyframes moveDots {
      0% {
        stroke-dashoffset: 15;
      }
      100% {
        stroke-dashoffset: 0;
      }
    }

    @keyframes moveArrow {
      0% {
        transform: translateX(15px) translateY(15px);
        opacity: 0.7;
      }
      100% {
        transform: translateX(0px) translateY(0px);
        opacity: 1;
      }
    }

    footer {
      position: absolute;
      bottom: 10px;
      left: 10px;
      font-size: 12px;
      color: #666;
      font-family: sans-serif;
      background-color: rgba(255,255,255,0.6);
      padding: 4px 8px;
      border-radius: 6px;
      z-index: 1001;
    }

    @keyframes pulse {
      0%   { background-color: #D5F5E3; }
      50%  { background-color: #ABEBC6; }
      100% { background-color: #D5F5E3; }
    }

    .row-active {
      animation: pulse 2s infinite;
    }

    #debug {
      position: absolute;
      bottom: 80px;
      right: 10px;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 10px;
      border-radius: 6px;
      font-family: monospace;
      font-size: 11px;
      max-width: 300px;
      z-index: 1001;
    }
    
  </style>
</head>
<body>
  <div id="map"></div>
  <div id="info">
    <strong>üì° GPS Data (I-XV)</strong>
    
    <button id="toggle-button" onclick="toggleTable()">Hide Table</button>
    <button id="toggle-trails1" onclick="toggleTrails1()">Hide Trails</button>
   
    <table id="device-table">
      <thead>
        <tr>
          <th>ID</th>
          <th>Lat</th>
          <th>Lon</th>
          <th>Count</th>
          <th>Sats</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
  </div>

  <div id="info2">
    <strong>üì° GPS Data (XVI-XXVII)</strong>
    
    <button id="toggle-button2" onclick="toggleTable2()">Hide Table</button>
    <button id="toggle-trails2" onclick="toggleTrails2()">Hide Trails</button>
   
    <table id="device-table2">
      <thead>
        <tr>
          <th>ID</th>
          <th>Lat</th>
          <th>Lon</th>
          <th>Count</th>
          <th>Sats</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
  </div>
  
  <div id="opacity-control">
    <label for="opacity-slider">Base Layer Opacity:</label>
    <input type="range" id="opacity-slider" min="0.1" max="1" step="0.1" value="1">
    <span id="opacity-value">100%</span>
  </div>
  
  <div id="debug">
    <strong>Debug Info:</strong><br>
    Connected: <span id="socket-status">‚ùå</span><br>
    Total Devices: <span id="device-count">0</span><br>
    Total Points: <span id="point-count">0</span><br>
    Last Update: <span id="last-update">never</span><br>
    Current Zoom: <span id="current-zoom">13</span>
  </div>

  <footer>
    üöÄ Last Render Build: <span id="build-time">loading...</span>
  </footer>
  
  <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script src="https://unpkg.com/esri-leaflet@3.0.10/dist/esri-leaflet.js"></script>
  <script>
    // Toggle table visibility functions
    function toggleTable() {
      const table = document.getElementById("device-table");
      const button = document.getElementById("toggle-button");
      
      if (table.style.display === "none") {
        table.style.display = "table";
        button.textContent = "Hide Table";
      } else {
        table.style.display = "none";
        button.textContent = "Show Table";
      }
    }

    function toggleTable2() {
      const table = document.getElementById("device-table2");
      const button = document.getElementById("toggle-button2");
      
      if (table.style.display === "none") {
        table.style.display = "table";
        button.textContent = "Hide Table";
      } else {
        table.style.display = "none";
        button.textContent = "Show Table";
      }
    }

    // Define device groups globally for reuse - attach to window for global access
    window.firstTableDevices = ['I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX', 'X', 'XI', 'XII', 'XIII', 'XIV', 'XV'];
    window.secondTableDevices = ['XVI', 'XVII', 'XVIII', 'XIX', 'XX', 'XXI', 'XXII', 'XXIII', 'XXIV', 'XXV', 'XXVI', 'XXVII'];
    const firstTableDevices = window.firstTableDevices;
    const secondTableDevices = window.secondTableDevices;

    // Trail visibility state
    let trails1Visible = true;
    let trails2Visible = true;

    // Toggle trail visibility functions
    function toggleTrails1() {
      const button = document.getElementById("toggle-trails1");
      
      trails1Visible = !trails1Visible;
      
      if (trails1Visible) {
        button.textContent = "Hide Trails";
        button.classList.remove("hidden-trails");
        // Show trails for devices I-XV
        firstTableDevices.forEach(deviceId => {
          showTrailsForDevice(deviceId);
        });
      } else {
        button.textContent = "Show Trails";
        button.classList.add("hidden-trails");
        // Hide trails for devices I-XV
        firstTableDevices.forEach(deviceId => {
          hideTrailsForDevice(deviceId);
        });
      }
    }

    function toggleTrails2() {
      const button = document.getElementById("toggle-trails2");
      
      trails2Visible = !trails2Visible;
      
      if (trails2Visible) {
        button.textContent = "Hide Trails";
        button.classList.remove("hidden-trails");
        // Show trails for devices XVI-XXVII
        secondTableDevices.forEach(deviceId => {
          showTrailsForDevice(deviceId);
        });
      } else {
        button.textContent = "Show Trails";
        button.classList.add("hidden-trails");
        // Hide trails for devices XVI-XXVII
        secondTableDevices.forEach(deviceId => {
          hideTrailsForDevice(deviceId);
        });
      }
    }

    function showTrailsForDevice(deviceId) {
      console.log(`Showing trails and markers for device: ${deviceId}`);
      
      // Show trails (polylines and arrows)
      if (trailLayers[deviceId]) {
        trailLayers[deviceId].forEach(layer => {
          if (!map.hasLayer(layer)) {
            layer.addTo(map);
          }
        });
      }
      
      // Show current position markers
      if (allMarkers[deviceId] && allMarkers[deviceId].current) {
        if (!map.hasLayer(allMarkers[deviceId].current.circle)) {
          allMarkers[deviceId].current.circle.addTo(map);
        }
        if (!map.hasLayer(allMarkers[deviceId].current.label)) {
          allMarkers[deviceId].current.label.addTo(map);
        }
      }
      
      // Show all history markers
      if (allMarkers[deviceId] && allMarkers[deviceId].history) {
        allMarkers[deviceId].history.forEach(marker => {
          if (!map.hasLayer(marker)) {
            marker.addTo(map);
          }
        });
      }
      
      // Hide large directional arrow if it exists
      if (window.largeArrows && window.largeArrows[deviceId]) {
        if (map.hasLayer(window.largeArrows[deviceId])) {
          map.removeLayer(window.largeArrows[deviceId]);
        }
        delete window.largeArrows[deviceId];
        console.log(`Large arrow removed for ${deviceId}`);
      }
    }

    function hideTrailsForDevice(deviceId) {
      console.log(`Hiding trails and markers for device: ${deviceId}`);
      
      // Hide trails (polylines and arrows)
      if (trailLayers[deviceId]) {
        trailLayers[deviceId].forEach(layer => {
          if (map.hasLayer(layer)) {
            map.removeLayer(layer);
          }
        });
      }
      
      // Hide current position markers
      if (allMarkers[deviceId] && allMarkers[deviceId].current) {
        if (map.hasLayer(allMarkers[deviceId].current.circle)) {
          map.removeLayer(allMarkers[deviceId].current.circle);
        }
        if (map.hasLayer(allMarkers[deviceId].current.label)) {
          map.removeLayer(allMarkers[deviceId].current.label);
        }
      }
      
      // Hide all history markers
      if (allMarkers[deviceId] && allMarkers[deviceId].history) {
        allMarkers[deviceId].history.forEach(marker => {
          if (map.hasLayer(marker)) {
            map.removeLayer(marker);
          }
        });
      }
      
      // Show large directional arrow
      createLargeDirectionalArrow(deviceId);
    }

    function createLargeDirectionalArrow(deviceId) {
      console.log(`Attempting to create large arrow for device: ${deviceId}`);
      
      const trail = gpsTrails[deviceId];
      if (!trail || trail.length < 2) {
        console.log(`Cannot create arrow for ${deviceId}: trail length = ${trail ? trail.length : 0}`);
        return;
      }
      
      const color = deviceColors[deviceId] || "#7F8C8D";
      console.log(`Creating large arrow for ${deviceId} with color ${color}`);
      
      // Get the last two points to determine direction
      const lastIndex = trail.length - 1;
      const startPoint = trail[lastIndex - 1];
      const endPoint = trail[lastIndex];
      
      console.log(`Start point:`, startPoint, `End point:`, endPoint);
      
      const bearing = calculateBearing(startPoint[0], startPoint[1], endPoint[0], endPoint[1]);
      console.log(`Arrow bearing for ${deviceId}: ${bearing} degrees`);
      
      // Create a simple large circle with device ID instead of arrow
      const circleHtml = `
        <div style="
          width: 50px;
          height: 50px;
          background-color: ${color};
          border: 4px solid white;
          border-radius: 50%;
          display: flex;
          align-items: center;
          justify-content: center;
          color: white;
          font-weight: bold;
          font-size: 14px;
          box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        ">${deviceId}</div>
      `;

      const largeArrowIcon = L.divIcon({
        html: circleHtml,
        className: 'large-directional-arrow',
        iconSize: [58, 58],
        iconAnchor: [29, 29]
      });

      // Position the arrow at the current location (end of trail)
      const largeArrow = L.marker(endPoint, { 
        icon: largeArrowIcon,
        interactive: true
      });
      
      // Add popup with device info
      const popupContent = `
        <strong>Device ID:</strong> ${deviceId}<br>
        <strong>Status:</strong> Trail Hidden<br>
        <strong>Last Position:</strong> ${endPoint[0].toFixed(6)}, ${endPoint[1].toFixed(6)}<br>
        <strong>Bearing:</strong> ${bearing.toFixed(1)}¬∞<br>
        <em>Click "Show Trails" to see full path</em>
      `;
      largeArrow.bindPopup(popupContent);
      
      // Store reference for cleanup
      if (!window.largeArrows) window.largeArrows = {};
      window.largeArrows[deviceId] = largeArrow;
      
      try {
        largeArrow.addTo(map);
        console.log(`‚úÖ Large circle marker successfully added to map for ${deviceId}`);
      } catch (error) {
        console.error(`‚ùå Error adding large circle marker for ${deviceId}:`, error);
      }
    }

    // Initialize map with higher max zoom
    const map = L.map("map", {
      maxZoom: 22  // Allow maximum zoom
    }).setView([-32.7686, 151.1790], 14);
    
    // Base layers with increased maxZoom and maxNativeZoom
    const osmLayer = L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      maxZoom: 22,
      maxNativeZoom: 19,  // OSM tiles go up to zoom 19
      attribution: "¬© OpenStreetMap contributors"
    });

    const nswTopoLayer = L.esri.tiledMapLayer({
      url: 'https://maps.six.nsw.gov.au/arcgis/rest/services/public/NSW_Topo_Map/MapServer',
      attribution: '¬© NSW Spatial Services',
      maxZoom: 22,
      maxNativeZoom: 16,  // NSW tiles typically go up to 16, but we'll allow upscaling
      opacity: 1
    });

    const nswImageryLayer = L.esri.tiledMapLayer({
      url: 'https://maps.six.nsw.gov.au/arcgis/rest/services/public/NSW_Imagery/MapServer',
      attribution: '¬© NSW Spatial Services',
      maxZoom: 22,
      maxNativeZoom: 18,  // Imagery usually has higher resolution
      opacity: 1
    });

    // Google Satellite imagery
    const worldImageryGoogle = L.tileLayer('https://mt1.google.com/vt/lyrs=s&x={x}&y={y}&z={z}', {
      attribution: '¬© Google',
      maxZoom: 22,
      maxNativeZoom: 20
    });

    // Add NSW Topo as default
    nswTopoLayer.addTo(map);
    let currentBaseLayer = nswTopoLayer;

    // Layer control with only the required maps
    const baseLayers = {
      "NSW Topographic": nswTopoLayer,
      "NSW Imagery": nswImageryLayer,
      "World Imagery (Google)": worldImageryGoogle,
      "OpenStreetMap": osmLayer
    };

    const layerControl = L.control.layers(baseLayers, null, {
      position: 'topleft'
    }).addTo(map);

    // Add zoom level display
    const currentZoomSpan = document.getElementById('current-zoom');
    map.on('zoomend', function() {
      currentZoomSpan.textContent = map.getZoom();
    });

    // Opacity control
    const opacitySlider = document.getElementById('opacity-slider');
    const opacityValue = document.getElementById('opacity-value');

    opacitySlider.addEventListener('input', function() {
      const opacity = parseFloat(this.value);
      currentBaseLayer.setOpacity(opacity);
      opacityValue.textContent = Math.round(opacity * 100) + '%';
    });

    // Update current base layer when user switches
    map.on('baselayerchange', function(e) {
      currentBaseLayer = e.layer;
      const opacity = parseFloat(opacitySlider.value);
      currentBaseLayer.setOpacity(opacity);
    });

    // Device colors - expanded for 27 devices with vibrant colors for better visibility
    const deviceColors = {
      '1': '#E74C3C', '2': '#3498DB', '3': '#2ECC71', '4': '#F39C12', '5': '#9B59B6',
      '6': '#1ABC9C', '7': '#E67E22', '8': '#34495E', '9': '#E91E63', '10': '#FF5722',
      '11': '#795548', '12': '#607D8B', '13': '#FF9800', '14': '#4CAF50', '15': '#673AB7',
      'I': '#E74C3C', 'II': '#3498DB', 'III': '#2ECC71', 'IV': '#F39C12', 'V': '#9B59B6',
      'VI': '#1ABC9C', 'VII': '#E67E22', 'VIII': '#34495E', 'IX': '#E91E63', 'X': '#FF5722',
      'XI': '#795548', 'XII': '#607D8B', 'XIII': '#FF9800', 'XIV': '#4CAF50', 'XV': '#673AB7',
      'XVI': '#FF1744', 'XVII': '#448AFF', 'XVIII': '#00E676', 'XIX': '#FFC107', 'XX': '#AB47BC',
      'XXI': '#26C6DA', 'XXII': '#FF6F00', 'XXIII': '#546E7A', 'XXIV': '#EC407A', 'XXV': '#8BC34A',
      'XXVI': '#5E35B1', 'XXVII': '#FF5252'
    };

    // Initialize socket connection
    const socket = io({ 
      transports: ['websocket'],
      timeout: 5000,
      forceNew: true
    });
    
    // Debug elements
    const socketStatus = document.getElementById('socket-status');
    const deviceCount = document.getElementById('device-count');
    const pointCount = document.getElementById('point-count');
    const lastUpdate = document.getElementById('last-update');
    
    let totalPoints = 0;

    // Socket connection handlers
    socket.on('connect', () => {
      console.log('‚úÖ Socket connected');
      socketStatus.textContent = '‚úÖ';
      socketStatus.style.color = '#2ECC71';
    });

    socket.on('disconnect', () => {
      console.log('‚ùå Socket disconnected');
      socketStatus.textContent = '‚ùå';
      socketStatus.style.color = '#E74C3C';
    });

    socket.on('connect_error', (error) => {
      console.error('Socket connection error:', error);
      socketStatus.textContent = '‚ö†Ô∏è';
      socketStatus.style.color = '#F39C12';
    });

    const gpsTrails = {};
    const packetCounts = {};
    const latestPackets = {};
    const allPointsBounds = L.latLngBounds();
    const allMarkers = {};
    const trailLayers = {};
    const deviceVisibility = {};
    let selectedDevice = null;
    let hasInitialData = false;

    function toggleDeviceVisibility(deviceId) {
      if (selectedDevice === deviceId) {
        selectedDevice = null;
        showAllDevices();
      } else {
        selectedDevice = deviceId;
        hideAllDevicesExcept(deviceId);
      }
    }

    function showAllDevices() {
      Object.keys(allMarkers).forEach(deviceId => {
        deviceVisibility[deviceId] = true;
        showDeviceMarkers(deviceId);
      });
    }

    function hideAllDevicesExcept(keepDeviceId) {
      Object.keys(allMarkers).forEach(deviceId => {
        if (deviceId === keepDeviceId) {
          deviceVisibility[deviceId] = true;
          showDeviceMarkers(deviceId);
        } else {
          deviceVisibility[deviceId] = false;
          hideDeviceMarkers(deviceId);
        }
      });
    }

    function showDeviceMarkers(deviceId) {
      // Check if trails are visible for this device group
      const shouldShowMarkers = (firstTableDevices.includes(deviceId) && trails1Visible) || 
                               (secondTableDevices.includes(deviceId) && trails2Visible);
      
      if (!shouldShowMarkers) return; // Don't show markers if trails are hidden
      
      if (allMarkers[deviceId] && allMarkers[deviceId].current) {
        allMarkers[deviceId].current.circle.addTo(map);
        allMarkers[deviceId].current.label.addTo(map);
      }
      
      if (allMarkers[deviceId] && allMarkers[deviceId].history) {
        allMarkers[deviceId].history.forEach(marker => {
          marker.addTo(map);
        });
      }
      
      if (trailLayers[deviceId]) {
        trailLayers[deviceId].forEach(layer => {
          layer.addTo(map);
        });
      }
    }

    function hideDeviceMarkers(deviceId) {
      if (allMarkers[deviceId] && allMarkers[deviceId].current) {
        map.removeLayer(allMarkers[deviceId].current.circle);
        map.removeLayer(allMarkers[deviceId].current.label);
      }
      
      if (allMarkers[deviceId] && allMarkers[deviceId].history) {
        allMarkers[deviceId].history.forEach(marker => {
          map.removeLayer(marker);
        });
      }
      
      if (trailLayers[deviceId]) {
        trailLayers[deviceId].forEach(layer => {
          map.removeLayer(layer);
        });
      }
    }

    function addDataPoint(point, isLatest = false) {
      const lat = parseFloat(point.latitude);
      const lon = parseFloat(point.longitude);
      
      // Validate coordinates
      if (isNaN(lat) || isNaN(lon) || lat < -90 || lat > 90 || lon < -180 || lon > 180) {
        console.warn('Invalid coordinates:', point);
        return;
      }

      const color = deviceColors[point.device_id] || "#7F8C8D";
      console.log(`Adding point for ${point.device_id}: (${lat}, ${lon}), isLatest: ${isLatest}`);

      if (isLatest) {
        const circle = L.circleMarker([lat, lon], {
          radius: 10,
          color: color,
          fillColor: color,
          fillOpacity: 0.7,
          weight: 3
        });

        const popupContent = `
          <strong>Device ID:</strong> ${point.device_id}<br>
          <strong>Latitude:</strong> ${lat.toFixed(6)}<br>
          <strong>Longitude:</strong> ${lon.toFixed(6)}<br>
          <strong>Timestamp:</strong> ${point.timestamp}<br>
          <strong>Satellites:</strong> ${point.sats || 'N/A'}
        `;
        circle.bindPopup(popupContent);

        const label = L.divIcon({
          html: `<div style="color: ${color}; font-weight: bold; text-shadow: 1px 1px 2px white;">${point.device_id}</div>`,
          className: 'device-label',
          iconSize: [20, 20]
        });

        const labelMarker = L.marker([lat, lon], { icon: label, interactive: false });
        
        if (!allMarkers[point.device_id]) allMarkers[point.device_id] = { current: null, history: [] };
        
        if (allMarkers[point.device_id].current) {
          map.removeLayer(allMarkers[point.device_id].current.circle);
          map.removeLayer(allMarkers[point.device_id].current.label);
        }
        
        allMarkers[point.device_id].current = { circle, label: labelMarker };
        
        // Add to map if device is visible
        if (deviceVisibility[point.device_id] !== false) {
          circle.addTo(map);
          labelMarker.addTo(map);
        }
        
        totalPoints++;
        
      } else {
        const isFirstPoint = !allMarkers[point.device_id] || allMarkers[point.device_id].history.length === 0;
        
        if (isFirstPoint) {
          const triangleIcon = L.divIcon({
            html: `<div style="
              width: 0; 
              height: 0; 
              border-left: 12px solid transparent;
              border-right: 12px solid transparent;
              border-bottom: 20px solid ${color};
              filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
            "></div>`,
            className: 'start-triangle',
            iconSize: [18, 18],
            iconAnchor: [9, 9]
          });

          const triangle = L.marker([lat, lon], { 
            icon: triangleIcon,
            interactive: true
          });

          const popupContent = `
            <strong>Device ID:</strong> ${point.device_id} (START)<br>
            <strong>Latitude:</strong> ${lat.toFixed(6)}<br>
            <strong>Longitude:</strong> ${lon.toFixed(6)}<br>
            <strong>Timestamp:</strong> ${point.timestamp}
          `;
          triangle.bindPopup(popupContent);

          if (!allMarkers[point.device_id]) allMarkers[point.device_id] = { current: null, history: [] };
          allMarkers[point.device_id].history.push(triangle);
          
          if (deviceVisibility[point.device_id] !== false) {
            triangle.addTo(map);
          }
          
          totalPoints++;
        } else {
          const pinIcon = L.divIcon({
            html: `<div style="
              width: 6px; 
              height: 6px; 
              background-color: ${color}; 
              border: 1px solid white; 
              border-radius: 50%;
              box-shadow: 0 0 2px rgba(0,0,0,0.3);
            "></div>`,
            className: 'history-pin',
            iconSize: [6, 6],
            iconAnchor: [3, 3]
          });

          const pin = L.marker([lat, lon], { 
            icon: pinIcon,
            interactive: true
          });

          const popupContent = `
            <strong>Device ID:</strong> ${point.device_id}<br>
            <strong>Latitude:</strong> ${lat.toFixed(6)}<br>
            <strong>Longitude:</strong> ${lon.toFixed(6)}<br>
            <strong>Timestamp:</strong> ${point.timestamp}
          `;
          pin.bindPopup(popupContent);

          if (!allMarkers[point.device_id]) allMarkers[point.device_id] = { current: null, history: [] };
          allMarkers[point.device_id].history.push(pin);
          
          if (deviceVisibility[point.device_id] !== false) {
            pin.addTo(map);
          }
          
          totalPoints++;
        }
      }
    }

    function calculateBearing(lat1, lon1, lat2, lon2) {
      const dLon = (lon2 - lon1) * Math.PI / 180;
      const lat1Rad = lat1 * Math.PI / 180;
      const lat2Rad = lat2 * Math.PI / 180;
      
      const y = Math.sin(dLon) * Math.cos(lat2Rad);
      const x = Math.cos(lat1Rad) * Math.sin(lat2Rad) - Math.sin(lat1Rad) * Math.cos(lat2Rad) * Math.cos(dLon);
      
      const bearing = Math.atan2(y, x) * 180 / Math.PI;
      return (bearing + 360) % 360;
    }

    function addArrowToSegment(p1, p2, color) {
      const midLat = (p1[0] + p2[0]) / 2;
      const midLon = (p1[1] + p2[1]) / 2;
      
      const bearing = calculateBearing(p1[0], p1[1], p2[0], p2[1]);
      
      const arrowSvg = `
        <svg width="32" height="32" viewBox="0 0 32 32" style="overflow: visible;">
          <g transform="translate(16, 16) rotate(${bearing - 90})">
            <polygon 
              points="-12,-10 12,0 -12,10 -6,0" 
              fill="${color}" 
              stroke="white" 
              stroke-width="2" 
            />
          </g>
        </svg>
      `;

      const arrowIcon = L.divIcon({
        html: arrowSvg,
        className: 'arrow-icon animated-arrow',
        iconSize: [32, 32],
        iconAnchor: [16, 16]
      });

      return L.marker([midLat, midLon], { icon: arrowIcon, interactive: false });
    }

    function drawTrail(device_id) {
      const trail = gpsTrails[device_id];
      if (!trail || trail.length < 2) return;
      
      const color = deviceColors[device_id] || "#7F8C8D";
      
      // Use window references to ensure global access
      const firstTableDevices = window.firstTableDevices;
      const secondTableDevices = window.secondTableDevices;

      if (trailLayers[device_id]) {
        trailLayers[device_id].forEach(layer => {
          if (map.hasLayer(layer)) {
            map.removeLayer(layer);
          }
        });
      }
      trailLayers[device_id] = [];

      // Create the main polyline with animated dots
      const polyline = L.polyline(trail, {
        color: color,
        weight: 4,
        opacity: 0.8,
        className: 'animated-polyline'
      });
      
      trailLayers[device_id].push(polyline);
      
      if (deviceVisibility[device_id] !== false && 
          ((firstTableDevices.includes(device_id) && trails1Visible) || 
           (secondTableDevices.includes(device_id) && trails2Visible))) {
        polyline.addTo(map);
      }

      // Add arrows along the trail - one arrow per segment
      for (let i = 0; i < trail.length - 1; i++) {
        const arrow = addArrowToSegment(trail[i], trail[i + 1], color);
        trailLayers[device_id].push(arrow);
        
        if (deviceVisibility[device_id] !== false &&
            ((firstTableDevices.includes(device_id) && trails1Visible) || 
             (secondTableDevices.includes(device_id) && trails2Visible))) {
          arrow.addTo(map);
        }
      }
    }

    function getAgeLabel(ts) {
      const iso = ts.replace(" ", "T") + "Z";
      const pingTime = new Date(iso);
      if (isNaN(pingTime)) {
        console.warn("Bad timestamp:", ts);
        return "‚Äî‚Äî";
      }

      const nowSec = Date.now();
      const diffSec = Math.floor((nowSec - pingTime.getTime()) / 1000);
      if (diffSec < 60)   return `${diffSec}s ago`;
      if (diffSec < 3600) return `${Math.floor(diffSec/60)}m ago`;
      return `${Math.floor(diffSec/3600)}h ago`;
    }

    function getRowClass(ts, sats) {
      const pingTime = new Date(ts);
      const now = new Date();
      const diff = (now - pingTime) / 1000;

      if (sats !== undefined && sats < 4) return "row-low-sats";

      if (diff <= 180) return "row-active";
      if (diff <= 360) return "row-warm";
      return "row-stale";
    }

    function updateTable() {
      const tbody1 = document.querySelector("#device-table tbody");
      const tbody2 = document.querySelector("#device-table2 tbody");
      tbody1.innerHTML = "";
      tbody2.innerHTML = "";

      const sortedIDs = Object.keys(latestPackets).sort((a, b) =>
        a.localeCompare(b, 'en', { sensitivity: 'base', numeric: true })
      );

      // Devices I-XV go to first table, XVI-XXVII go to second table
      const firstTableDevices = ['I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX', 'X', 'XI', 'XII', 'XIII', 'XIV', 'XV'];
      const secondTableDevices = ['XVI', 'XVII', 'XVIII', 'XIX', 'XX', 'XXI', 'XXII', 'XXIII', 'XXIV', 'XXV', 'XXVI', 'XXVII'];

      for (const id of sortedIDs) {
        const packet = latestPackets[id];
        const count  = packetCounts[id] || 0;
        const sats   = packet.sats ?? "‚Äî";
        const lat    = parseFloat(packet.latitude).toFixed(6);
        const lon    = parseFloat(packet.longitude).toFixed(6);

        const row = document.createElement("tr");
        row.className = getRowClass(packet.timestamp, packet.sats);

        row.innerHTML = `
          <td>${id}</td>
          <td>${lat}</td>
          <td>${lon}</td>
          <td>${count}</td>
          <td>${sats}</td>
        `;

        row.style.cursor = "pointer";
        row.addEventListener("click", () => {
          toggleDeviceVisibility(id);
          updateTable();
        });

        if (selectedDevice === id) {
          row.style.border = "2px solid #3498DB";
        }

        // Add row to appropriate table
        if (firstTableDevices.includes(id)) {
          tbody1.appendChild(row);
        } else if (secondTableDevices.includes(id)) {
          tbody2.appendChild(row);
        }
      }
    }

    function updateDebugInfo() {
      deviceCount.textContent = Object.keys(latestPackets).length;
      pointCount.textContent = totalPoints;
      lastUpdate.textContent = new Date().toLocaleTimeString();
    }
    
    socket.on("gps_update", (data) => {
      processGPSUpdate(data);
    });

    // Test data generator for debugging (remove in production) - now supports 27 devices
    function generateTestData() {
      const testDevices = ['I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX', 'X', 'XI', 'XII', 'XIII', 'XIV', 'XV',
                          'XVI', 'XVII', 'XVIII', 'XIX', 'XX', 'XXI', 'XXII', 'XXIII', 'XXIV', 'XXV', 'XXVI', 'XXVII'];
      const baseLat = -33.87;
      const baseLon = 151.21;
      
      testDevices.forEach((deviceId, index) => {
        const lat = baseLat + (Math.random() - 0.5) * 0.01;
        const lon = baseLon + (Math.random() - 0.5) * 0.01;
        
        const testData = {
          device_id: deviceId,
          latitude: lat.toString(),
          longitude: lon.toString(),
          timestamp: new Date().toISOString().replace('T', ' ').replace('Z', ''),
          sats: Math.floor(Math.random() * 12) + 4
        };
        
        // Process test data directly instead of emitting through socket
        processGPSUpdate(testData);
      });
    }

    // Extract GPS processing logic into a separate function
    function processGPSUpdate(data) {
      console.log('üì° Processing GPS update:', data);
      
      const { latitude, longitude, device_id, timestamp } = data;
      if (!latitude || !longitude || !device_id || !timestamp) {
        console.warn('Missing required data:', data);
        return;
      }

      const lat = parseFloat(latitude);
      const lon = parseFloat(longitude);
      
      if (isNaN(lat) || isNaN(lon)) {
        console.warn('Invalid coordinates:', data);
        return;
      }

      // Store the packet with corrected timestamp
      latestPackets[device_id] = {
        ...data,
        timestamp: timestamp.replace(" ", "T") + "Z"
      };

      packetCounts[device_id] = (packetCounts[device_id] || 0) + 1;

      // Move the last "current" point into history
      if (gpsTrails[device_id] && gpsTrails[device_id].length) {
        const lastPoint = {
          ...latestPackets[device_id],
          latitude: gpsTrails[device_id][gpsTrails[device_id].length - 1][0],
          longitude: gpsTrails[device_id][gpsTrails[device_id].length - 1][1]
        };
        addDataPoint(lastPoint, false);
      }
      
      // Add the new current marker
      addDataPoint(data, true);

      // Update map bounds
      allPointsBounds.extend([lat, lon]);
      
      // Only fit bounds on first data or if bounds are empty - allow user to zoom freely
      if (!hasInitialData) {
        map.fitBounds(allPointsBounds, { padding: [30, 30], maxZoom: 16 });
        hasInitialData = true;
      }

      // Build the trail
      gpsTrails[device_id] = gpsTrails[device_id] || [];
      gpsTrails[device_id].push([lat, lon]);
      if (gpsTrails[device_id].length > 100) gpsTrails[device_id].shift();

      // Redraw trail with arrows
      drawTrail(device_id);

      // Update UI
      updateTable();
      updateDebugInfo();

      console.log(`üìç ${device_id} ‚Üí (${lat.toFixed(6)}, ${lon.toFixed(6)}) | count=${packetCounts[device_id]}`);
    }

    // Uncomment the line below to generate test data every 5 seconds
    // setInterval(generateTestData, 5000);

    setInterval(updateTable, 10000);
    
    document.getElementById("build-time").textContent =
      new Date().toLocaleString("en-AU", {
        timeZone: "Australia/Sydney",
        hour12: false,
        year: 'numeric',
        month: 'short',
        day: 'numeric',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit'
      });
  </script>
</body>
</html>
