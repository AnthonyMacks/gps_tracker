<!DOCTYPE html>

<html>
<head><style>
.lower-right-image {
    position: absolute;
    bottom: 20px;
    right: 20px;
    max-width: 120px;
    z-index: 1000;
}

</style>
<title>Live GPS Tracker v1.9 - NSW Topo + World Imagery</title>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" name="viewport"/>
<link href="https://unpkg.com/leaflet/dist/leaflet.css" rel="stylesheet"/>
<style>
    body, html { margin: 0; padding: 0; height: 100%; }
    #map { height: 100%; width: 100%; z-index: 0; }

    #info {
      position: absolute;
      top: 10px;
      right: 10px;
      max-width: 340px;
      max-height: 70%;
      overflow-y: auto;
      background: rgba(255,255,255,0.85);
      padding: 10px;
      border-radius: 8px;
      font-family: sans-serif;
      font-size: 13px;
      color: #2C3E50;
      box-shadow: 0 0 6px rgba(0,0,0,0.2);
      z-index: 1001;
      cursor: move;
      user-select: none;
    }

    #info2 {
      position: absolute;
      top: 10px;
      right: 370px;
      max-width: 340px;
      max-height: 70%;
      overflow-y: auto;
      background: rgba(255,255,255,0.85);
      padding: 10px;
      border-radius: 8px;
      font-family: sans-serif;
      font-size: 13px;
      color: #2C3E50;
      box-shadow: 0 0 6px rgba(0,0,0,0.2);
      z-index: 1001;
      cursor: move;
      user-select: none;
    }

    #info.dragging, #info2.dragging {
      opacity: 0.8;
      cursor: grabbing;
    }

    #toggle-button, #toggle-button2 {
      background-color: #0078D7;
      color: white;
      border: none;
      padding: 8px 16px;
      font-size: 14px;
      border-radius: 4px;
      cursor: pointer;
      margin-bottom: 10px;
      width: 100%;
    }
    
    #toggle-button:hover, #toggle-button2:hover {
      background-color: #005A9E;
    }

    #opacity-control {
      position: absolute;
      bottom: 60px;
      left: 10px;
      background: rgba(255,255,255,0.9);
      padding: 10px;
      border-radius: 6px;
      font-family: sans-serif;
      font-size: 12px;
      box-shadow: 0 0 6px rgba(0,0,0,0.2);
      z-index: 1001;
    }

    #opacity-control label {
      display: block;
      margin-bottom: 5px;
      font-weight: bold;
    }

    #opacity-control input[type="range"] {
      width: 150px;
      margin-right: 10px;
    }

    #grid-control {
      position: absolute;
      bottom: 120px;
      left: 10px;
      background: rgba(255,255,255,0.9);
      padding: 10px;
      border-radius: 6px;
      font-family: sans-serif;
      font-size: 12px;
      box-shadow: 0 0 6px rgba(0,0,0,0.2);
      z-index: 1001;
    }

    #grid-control label {
      display: flex;
      align-items: center;
      cursor: pointer;
    }

    #grid-control input[type="checkbox"] {
      margin-right: 8px;
      cursor: pointer;
    }

    .grid-label-marker {
      background: transparent !important;
      border: none !important;
    }

    .row-active { background-color: #D5F5E3; }
    .row-warm   { background-color: #FCF3CF; }
    .row-stale  { background-color: #FADBD8; }

    .row-low-sats {
      background-color: #F5B7B1 !important;
      animation: blink 1s step-start infinite;
    }

    @keyframes blink {
      50% { background-color: #FADBD8; }
    }

    .device-label {
      background: transparent;
      color: black;
      font-weight: bold;
      text-align: center;
      line-height: 24px;
      font-size: 11px;
    }

    .arrow-icon {
      font-weight: bold;
      font-size: 8px;
    }

    footer {
      position: absolute;
      bottom: 10px;
      left: 10px;
      font-size: 12px;
      color: #666;
      font-family: sans-serif;
      background-color: rgba(255,255,255,0.6);
      padding: 4px 8px;
      border-radius: 6px;
      z-index: 1001;
    }

    @keyframes pulse {
      0%   { background-color: #D5F5E3; }
      50%  { background-color: #ABEBC6; }
      100% { background-color: #D5F5E3; }
    }

    .row-active {
      animation: pulse 2s infinite;
    }

    #debug {
      position: absolute;
      bottom: 160px;
      right: 10px;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 10px;
      border-radius: 6px;
      font-family: monospace;
      font-size: 11px;
      max-width: 300px;
      z-index: 1001;
      transition: all 0.3s ease;
      cursor: pointer;
      height: auto;
      min-height: 20px;
    }

    #debug.collapsed {
      height: 25px;
      padding: 5px 10px;
      overflow: hidden;
    }

    #debug .debug-content {
      transition: all 0.3s ease;
      opacity: 1;
      max-height: 200px;
    }

    #debug.collapsed .debug-content {
      opacity: 0;
      max-height: 0;
      margin-top: -5px;
    }

    #debug .debug-title {
      font-weight: bold;
      margin-bottom: 5px;
      font-size: 11px;
    }

    #debug.collapsed .debug-title {
      margin-bottom: 0;
      font-size: 10px;
    }

    /* Animated dots on polyline */
    .animated-polyline {
      stroke-dasharray: 1, 14;
      stroke-linecap: round;
      animation: moveDots 4s linear infinite;
    }

    @keyframes moveDots {
      0% {
        stroke-dashoffset: 15;
      }
      100% {
        stroke-dashoffset: 0;
      }
    }

    table {
      width: 100%;
      border-collapse: collapse;
      margin: 0 auto;
    }
    
    th, td {
      border: 1px solid #ddd;
      padding: 12px;
      text-align: center;
    }
    
    th {
      background-color: #f8f9fa;
      font-weight: bold;
      color: #333;
      position: sticky;
      top: 0;
    }
    
    tr:nth-child(even) {
      background-color: #f9f9f9;
    }
    
    tr:hover {
      background-color: #e6f3ff;
    }

    .hidden {
      display: none;
    }

    .row-number {
      background-color: #e9ecef;
      font-weight: bold;
    }

    /* Mobile responsive styles */
    @media (max-width: 768px) {
      #info {
        max-width: none;
        width: calc(45% - 10px);
        max-height: 35%;
        font-size: 11px;
        padding: 6px;
      }

      #info2 {
        max-width: none;
        width: calc(45% - 10px);
        max-height: 35%;
        font-size: 11px;
        padding: 6px;
      }

      #info strong, #info2 strong {
        font-size: 12px;
      }

      table {
        font-size: 10px;
      }

      th, td {
        padding: 4px 2px;
      }

      #toggle-button, #toggle-button2 {
        font-size: 12px;
        padding: 6px 12px;
      }

      #opacity-control {
        bottom: 60px;
        left: 10px;
        font-size: 10px;
        padding: 6px;
      }

      #grid-control {
        bottom: 110px;
        left: 10px;
        font-size: 10px;
        padding: 6px;
      }

      #debug {
        bottom: 140px;
        left: 10px;
        font-size: 9px;
        padding: 6px;
        max-width: 200px;
      }

      #debug.collapsed {
        height: 22px;
        padding: 4px 6px;
      }

      #debug .debug-title {
        font-size: 9px;
      }

      #debug.collapsed .debug-title {
        font-size: 8px;
      }

      footer {
        bottom: 10px;
        left: 10px;
        font-size: 10px;
        padding: 2px 4px;
      }
    }

    /* Portrait phone adjustments */
    @media (max-width: 480px) and (orientation: portrait) {
      #info {
        max-height: 30%;
        font-size: 10px;
        width: calc(48% - 10px);
      }

      #info2 {
        max-height: 30%;
        font-size: 10px;
        width: calc(48% - 10px);
      }

      table {
        font-size: 9px;
      }

      th, td {
        padding: 3px 1px;
      }

      #toggle-button, #toggle-button2 {
        font-size: 11px;
        padding: 5px 10px;
      }

      #opacity-control {
        bottom: 60px;
        left: 10px;
        font-size: 9px;
        padding: 4px;
      }

      #grid-control {
        bottom: 100px;
        left: 10px;
        font-size: 9px;
        padding: 4px;
      }

      #grid-control button {
        font-size: 7px;
        padding: 1px 3px;
      }

      #debug {
        bottom: 130px;
        right: 10px;
        left: auto;
        font-size: 8px;
        padding: 4px;
        max-width: 150px;
      }

      #debug.collapsed {
        height: 18px;
        padding: 3px 4px;
      }

      #debug .debug-title {
        font-size: 8px;
      }

      #debug.collapsed .debug-title {
        font-size: 7px;
      }

      footer {
        font-size: 9px;
      }
    }

    /* Landscape phone adjustments */
    @media (max-width: 768px) and (orientation: landscape) {
      #info {
        width: 220px;
        max-width: 220px;
        max-height: 40%;
      }

      #info2 {
        width: 220px;
        max-width: 220px;
        max-height: 40%;
      }

      #opacity-control {
        bottom: 10px;
        left: 10px;
        font-size: 10px;
      }

      #grid-control {
        bottom: 50px;
        left: 10px;
        font-size: 10px;
      }

      #debug {
        bottom: 140px;
        right: 10px;
        left: auto;
        font-size: 9px;
        max-width: 180px;
      }

      #debug.collapsed {
        height: 20px;
        padding: 4px 6px;
      }

      #debug .debug-title {
        font-size: 9px;
      }

      #debug.collapsed .debug-title {
        font-size: 8px;
      }
    }
    
  </style>
</head>
<body><img alt="SCU Crest" class="lower-right-image" src="https://raw.githubusercontent.com/AnthonyMacks/gps_tracker/main/templates/scucrest.png"/>
<div id="map"></div>
<div id="info">
<strong>📡 GPS MacksTrack Data (I-XII) <span style="float: right; cursor: move; font-size: 18px;">☰</span></strong>
<button id="toggle-button" onclick="toggleTable()">Hide Table</button>
<table id="device-table">
<thead>
<tr>
<th>ID</th>
<th>Grid Ref</th>
<th>Count</th>
<th>Sats</th>
</tr>
</thead>
<tbody></tbody>
</table>
</div>
<div id="info2">
<strong>📡 GPS MacksTrack Data (XIII-XXX) <span style="float: right; cursor: move; font-size: 18px;">☰</span></strong>
<button id="toggle-button2" onclick="toggleTable2()">Hide Table</button>
<table id="device-table2">
<thead>
<tr>
<th>ID</th>
<th>Grid Ref</th>
<th>Count</th>
<th>Sats</th>
</tr>
</thead>
<tbody></tbody>
</table>
</div>
<div id="opacity-control">
<label for="opacity-slider">Base Layer Opacity:</label>
<input id="opacity-slider" max="1" min="0.1" step="0.1" type="range" value="1"/>
<span id="opacity-value">100%</span>
</div>
<div id="grid-control">
<label>
  <input type="checkbox" id="grid-toggle" checked/>
  Show 1km Grid Lines
</label>
<br/>
<label style="margin-top: 5px;">
  <input type="checkbox" id="grid-100m-toggle"/>
  Show 100m Grid Lines
</label>
</div>
<div id="debug" class="collapsed">
<div class="debug-title">Debug Info</div>
<div class="debug-content">
    Connected: <span id="socket-status">❌</span><br/>
    Total Devices: <span id="device-count">0</span><br/>
    Total Points: <span id="point-count">0</span><br/>
    Rejected Points: <span id="rejected-count">0</span><br/>
    Last Update: <span id="last-update">never</span><br/>
    Current Zoom: <span id="current-zoom">13</span>
</div>
</div>
<footer>
    🚀 Last Render Build: <span id="build-time">loading...</span>
</footer>
<script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
<script src="https://unpkg.com/esri-leaflet@3.0.10/dist/esri-leaflet.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.9.0/proj4.min.js"></script>
<script>
    // Define MGA zones for both GDA94 and GDA2020
    // GDA2020 (EPSG:78xx)
    proj4.defs("EPSG:7854", "+proj=utm +zone=54 +south +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs");
    proj4.defs("EPSG:7855", "+proj=utm +zone=55 +south +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs");
    proj4.defs("EPSG:7856", "+proj=utm +zone=56 +south +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs");
    
    // GDA94 (EPSG:283xx) - NSW Topo maps may use this
    proj4.defs("EPSG:28354", "+proj=utm +zone=54 +south +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs");
    proj4.defs("EPSG:28355", "+proj=utm +zone=55 +south +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs");
    proj4.defs("EPSG:28356", "+proj=utm +zone=56 +south +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs");

    // Grid reference conversion using proj4js
    const e100kLetters = "ABCDEFGHJKLMNPQRSTUVWXYZ";
    const n100kLetters = "ABCDEFGHJKLMNPQRSTUV";
    
    let useGDA94 = true; // Use GDA94 for NSW Topo compatibility

    function getUTMZone(lon) {
      // Standard UTM zone calculation
      // Zone 55: 144° to 150°
      // Zone 56: 150° to 156°
      // Zone 57: 156° to 162°
      if (lon >= 144 && lon < 150) return 55;
      if (lon >= 150 && lon < 156) return 56;
      if (lon >= 156 && lon < 162) return 57;
      // Default to zone 56 for NSW
      return 56;
    }
    
    function getEPSG(zone) {
      if (useGDA94) {
        return 28354 + (zone - 54); // GDA94: 28354, 28355, 28356
      } else {
        return 7854 + (zone - 54);  // GDA2020: 7854, 7855, 7856
      }
    }

    function get100kmGridSquare(easting, northing, zone) {
      // MGA Grid Square calculation for Australian zones
      const e100k = Math.floor(easting / 100000);
      const n100k = Math.floor(northing / 100000);
      
      // For Australian MGA (GDA94/GDA2020)
      // Zone 54: columns start at 'Q'
      // Zone 55: columns start at 'A' 
      // Zone 56: columns start at 'J'
      // Zone 57: columns start at 'S'
      
      let colStart;
      if (zone === 54) colStart = 16; // Q
      else if (zone === 55) colStart = 0;  // A
      else if (zone === 56) colStart = 9;  // J
      else if (zone === 57) colStart = 18; // S
      else colStart = 0;
      
      // Easting index cycles through 8 letters
      const eIndex = (colStart + (e100k - 1)) % 24;
      
      // Northing index - in southern hemisphere
      // For southern zones, the northing letters count from south (A) at equator
      // At equator N=10000000m, each letter is 100km
      // For 6,295,000m: (10,000,000 - 6,295,000) / 100,000 = 37.05
      // So we're 37 squares south of equator
      
      // The northing index in MGRS repeats every 2000km (20 letters × 100km)
      const nIndex = (n100k) % 20;
      
      const gridSquare = e100kLetters[eIndex] + n100kLetters[nIndex];
      
      console.log(`Grid Square Debug: Zone=${zone}, E100k=${e100k}, N100k=${n100k}, eIndex=${eIndex}(${e100kLetters[eIndex]}), nIndex=${nIndex}(${n100kLetters[nIndex]}), Grid=${gridSquare}`);
      
      return gridSquare;
    }

    function latLonToGridReference(lat, lon) {
      try {
        const zone = getUTMZone(lon);
        const epsg = getEPSG(zone);
        
        const utm = proj4('EPSG:4326', `EPSG:${epsg}`, [lon, lat]);
        const easting = utm[0];
        const northing = utm[1];

        const gridSquare = get100kmGridSquare(easting, northing, zone);
        
        const eastingRemainder = Math.floor(easting % 100000);
        const northingRemainder = Math.floor(northing % 100000);
        
        const eastingStr = eastingRemainder.toString().padStart(5, '0').substring(0, 4);
        const northingStr = northingRemainder.toString().padStart(5, '0').substring(0, 4);
        
        return `${eastingStr} ${northingStr}`;
      } catch (error) {
        console.error('Grid conversion error:', error);
        return `${lat.toFixed(4)}, ${lon.toFixed(4)}`;
      }
    }

    // Grid line management
    let gridLinesVisible = true;
    let grid100mVisible = false;
    let gridLineLayer = null;
    let grid100mLayer = null;
    let gridLabelMarkers = [];

    function clearGridLines() {
      if (gridLineLayer) {
        map.removeLayer(gridLineLayer);
        gridLineLayer = null;
      }
      gridLabelMarkers.forEach(marker => map.removeLayer(marker));
      gridLabelMarkers = [];
    }

    function clearGrid100m() {
      if (grid100mLayer) {
        map.removeLayer(grid100mLayer);
        grid100mLayer = null;
      }
    }

    function drawGridLines() {
      if (!gridLinesVisible) return;

      clearGridLines();

      try {
        const bounds = map.getBounds();
        const center = map.getCenter();
        const zoom = map.getZoom();

        // Don't draw grid at very low zoom levels
        if (zoom < 12) {
          console.log('Zoom too low for grid display');
          return;
        }

        const lat = center.lat;
        const lon = center.lng;
        const zone = getUTMZone(lon);
        const epsg = getEPSG(zone);

        // Convert bounds to UTM
        const sw = proj4('EPSG:4326', `EPSG:${epsg}`, [bounds.getWest(), bounds.getSouth()]);
        const ne = proj4('EPSG:4326', `EPSG:${epsg}`, [bounds.getEast(), bounds.getNorth()]);

        // Round to exact 1km boundaries
        const minE = Math.floor(sw[0] / 1000) * 1000;
        const maxE = Math.ceil(ne[0] / 1000) * 1000;
        const minN = Math.floor(sw[1] / 1000) * 1000;
        const maxN = Math.ceil(ne[1] / 1000) * 1000;

        const gridInterval = zoom >= 15 ? 1000 : zoom >= 13 ? 2000 : 5000;

        const allLines = [];
        const labels = [];

        console.log(`Drawing grid for zone ${zone}, datum: GDA94, interval: ${gridInterval}m`);

        // Draw vertical lines (easting)
        for (let e = minE; e <= maxE; e += gridInterval) {
          const line = [];
          for (let n = minN; n <= maxN; n += 250) {
            try {
              const ll = proj4(`EPSG:${epsg}`, 'EPSG:4326', [e, n]);
              line.push([ll[1], ll[0]]);
            } catch (err) {
              console.warn('Grid conversion error:', err);
            }
          }
          
          if (line.length > 1) {
            allLines.push(line);
            
            // Add label at top of line
            const eastingLabel = (e % 100000).toString().padStart(5, '0').substring(0, 4);
            try {
              const ll = proj4(`EPSG:${epsg}`, 'EPSG:4326', [e, maxN - 1000]);
              labels.push({
                position: [ll[1], ll[0]],
                text: `E${eastingLabel}`,
                color: '#ff0000'
              });
            } catch (err) {
              console.warn('Label position error:', err);
            }
          }
        }

        // Draw horizontal lines (northing)
        for (let n = minN; n <= maxN; n += gridInterval) {
          const line = [];
          for (let e = minE; e <= maxE; e += 250) {
            try {
              const ll = proj4(`EPSG:${epsg}`, 'EPSG:4326', [e, n]);
              line.push([ll[1], ll[0]]);
            } catch (err) {
              console.warn('Grid conversion error:', err);
            }
          }
          
          if (line.length > 1) {
            allLines.push(line);
            
            // Add label at left of line
            const northingLabel = (n % 100000).toString().padStart(5, '0').substring(0, 4);
            try {
              const ll = proj4(`EPSG:${epsg}`, 'EPSG:4326', [minE + 1000, n]);
              labels.push({
                position: [ll[1], ll[0]],
                text: `N${northingLabel}`,
                color: '#ff0000'
              });
            } catch (err) {
              console.warn('Label position error:', err);
            }
          }
        }

        // Create multi-polyline for all grid lines
        if (allLines.length > 0) {
          gridLineLayer = L.polyline(allLines, {
            color: '#ff0000',
            weight: 2,
            opacity: 0.7,
            interactive: false
          }).addTo(map);
        }

        // Add labels
        labels.forEach(label => {
          const marker = L.marker(label.position, {
            icon: L.divIcon({
              className: 'grid-label-marker',
              html: `<div style="background: rgba(255,255,255,0.95); padding: 3px 6px; font-size: 11px; font-weight: bold; border: 2px solid ${label.color}; border-radius: 3px; box-shadow: 0 2px 4px rgba(0,0,0,0.4); white-space: nowrap; color: ${label.color};">${label.text}</div>`,
              iconSize: [55, 22],
              iconAnchor: [27, 11]
            }),
            interactive: false
          }).addTo(map);
          
          gridLabelMarkers.push(marker);
        });

        console.log(`Drew ${allLines.length} grid lines with ${labels.length} labels at zoom ${zoom}`);

        // Draw 100m grid if enabled
        if (grid100mVisible) {
          draw100mGrid();
        }

      } catch (error) {
        console.error('Error drawing grid lines:', error);
      }
    }

    function draw100mGrid() {
      clearGrid100m();

      try {
        const bounds = map.getBounds();
        const center = map.getCenter();
        const zoom = map.getZoom();

        // Only draw 100m grid at high zoom levels
        if (zoom < 15) {
          console.log('Zoom too low for 100m grid display');
          return;
        }

        const lat = center.lat;
        const lon = center.lng;
        const zone = getUTMZone(lon);
        const epsg = getEPSG(zone);

        // Convert bounds to UTM
        const sw = proj4('EPSG:4326', `EPSG:${epsg}`, [bounds.getWest(), bounds.getSouth()]);
        const ne = proj4('EPSG:4326', `EPSG:${epsg}`, [bounds.getEast(), bounds.getNorth()]);

        // Round to exact 100m boundaries
        const minE = Math.floor(sw[0] / 100) * 100;
        const maxE = Math.ceil(ne[0] / 100) * 100;
        const minN = Math.floor(sw[1] / 100) * 100;
        const maxN = Math.ceil(ne[1] / 100) * 100;

        const allLines = [];

        console.log(`Drawing 100m grid for zone ${zone}`);

        // Draw vertical lines every 100m
        for (let e = minE; e <= maxE; e += 100) {
          // Skip lines that are on 1km boundaries (already drawn)
          if (e % 1000 === 0) continue;
          
          const line = [];
          for (let n = minN; n <= maxN; n += 50) {
            try {
              const ll = proj4(`EPSG:${epsg}`, 'EPSG:4326', [e, n]);
              line.push([ll[1], ll[0]]);
            } catch (err) {
              console.warn('100m grid conversion error:', err);
            }
          }
          
          if (line.length > 1) {
            allLines.push(line);
          }
        }

        // Draw horizontal lines every 100m
        for (let n = minN; n <= maxN; n += 100) {
          // Skip lines that are on 1km boundaries (already drawn)
          if (n % 1000 === 0) continue;
          
          const line = [];
          for (let e = minE; e <= maxE; e += 50) {
            try {
              const ll = proj4(`EPSG:${epsg}`, 'EPSG:4326', [e, n]);
              line.push([ll[1], ll[0]]);
            } catch (err) {
              console.warn('100m grid conversion error:', err);
            }
          }
          
          if (line.length > 1) {
            allLines.push(line);
          }
        }

        // Create multi-polyline for all 100m grid lines (dashed, blue/gray)
        if (allLines.length > 0) {
          grid100mLayer = L.polyline(allLines, {
            color: '#3366cc',
            weight: 1,
            opacity: 0.4,
            dashArray: '4, 4',
            interactive: false
          }).addTo(map);
        }

        console.log(`Drew ${allLines.length} 100m grid lines at zoom ${zoom}`);

      } catch (error) {
        console.error('Error drawing 100m grid lines:', error);
      }
    }

    function toggleGridLines() {
      gridLinesVisible = !gridLinesVisible;
      if (gridLinesVisible) {
        drawGridLines();
      } else {
        clearGridLines();
        clearGrid100m(); // Also clear 100m grid if main grid is off
      }
    }

    function toggle100mGrid() {
      grid100mVisible = !grid100mVisible;
      if (grid100mVisible) {
        if (!gridLinesVisible) {
          // Enable main grid first if it's off
          gridLinesVisible = true;
          document.getElementById('grid-toggle').checked = true;
          drawGridLines(); // This will also draw 100m grid
        } else {
          draw100mGrid();
        }
      } else {
        clearGrid100m();
      }
    }

    // Distance validation - store start points for each device
    const deviceStartPoints = {};
    const MAX_DISTANCE_KM = 5;
    let rejectedPointsCount = 0;

    // Haversine formula to calculate distance between two lat/lon points in kilometers
    function calculateDistance(lat1, lon1, lat2, lon2) {
      const R = 6371; // Earth's radius in kilometers
      const dLat = (lat2 - lat1) * Math.PI / 180;
      const dLon = (lon2 - lon1) * Math.PI / 180;
      const a = 
        Math.sin(dLat/2) * Math.sin(dLat/2) +
        Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * 
        Math.sin(dLon/2) * Math.sin(dLon/2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
      return R * c; // Distance in kilometres
    }

    // Validate if point is within acceptable distance from start
    function isValidDistance(deviceId, lat, lon) {
      // If this is the first point for this device, store it as the start point
      if (!deviceStartPoints[deviceId]) {
        deviceStartPoints[deviceId] = { lat: lat, lon: lon };
        console.log(`📍 Setting start point for device ${deviceId}: (${lat.toFixed(6)}, ${lon.toFixed(6)})`);
        return true;
      }

      // Calculate distance from start point
      const startPoint = deviceStartPoints[deviceId];
      const distance = calculateDistance(startPoint.lat, startPoint.lon, lat, lon);
      
      console.log(`📏 Device ${deviceId} distance from start: ${distance.toFixed(2)}km`);
      
      if (distance > MAX_DISTANCE_KM) {
        console.warn(`🚫 Rejecting point for device ${deviceId}: ${distance.toFixed(2)}km > ${MAX_DISTANCE_KM}km limit`);
        rejectedPointsCount++;
        return false;
      }
      
      return true;
    }

    // Toggle table visibility functions
    function toggleTable() {
      const table = document.getElementById("device-table");
      const button = document.getElementById("toggle-button");
      
      if (table.style.display === "none") {
        table.style.display = "table";
        button.textContent = "Hide Table";
      } else {
        table.style.display = "none";
        button.textContent = "Show Table";
      }
    }

    function toggleTable2() {
      const table = document.getElementById("device-table2");
      const button = document.getElementById("toggle-button2");
      
      if (table.style.display === "none") {
        table.style.display = "table";
        button.textContent = "Hide Table";
      } else {
        table.style.display = "none";
        button.textContent = "Show Table";
      }
    }

    // Make panels draggable
    function makeDraggable(element) {
      let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
      let isDragging = false;

      element.onmousedown = dragMouseDown;
      element.ontouchstart = dragTouchStart;

      function dragMouseDown(e) {
        // Don't drag if clicking on buttons or table
        if (e.target.tagName === 'BUTTON' || e.target.tagName === 'INPUT' || 
            e.target.closest('table') || e.target.closest('button')) {
          return;
        }
        
        e.preventDefault();
        pos3 = e.clientX;
        pos4 = e.clientY;
        isDragging = true;
        element.classList.add('dragging');
        document.onmouseup = closeDragElement;
        document.onmousemove = elementDrag;
      }

      function dragTouchStart(e) {
        // Don't drag if touching buttons or table
        if (e.target.tagName === 'BUTTON' || e.target.tagName === 'INPUT' || 
            e.target.closest('table') || e.target.closest('button')) {
          return;
        }
        
        const touch = e.touches[0];
        pos3 = touch.clientX;
        pos4 = touch.clientY;
        isDragging = true;
        element.classList.add('dragging');
        document.ontouchend = closeDragElement;
        document.ontouchmove = elementDragTouch;
      }

      function elementDrag(e) {
        if (!isDragging) return;
        e.preventDefault();
        pos1 = pos3 - e.clientX;
        pos2 = pos4 - e.clientY;
        pos3 = e.clientX;
        pos4 = e.clientY;
        
        const newTop = element.offsetTop - pos2;
        const newLeft = element.offsetLeft - pos1;
        
        element.style.top = newTop + "px";
        element.style.left = newLeft + "px";
        element.style.right = "auto";
        element.style.bottom = "auto";
      }

      function elementDragTouch(e) {
        if (!isDragging) return;
        const touch = e.touches[0];
        pos1 = pos3 - touch.clientX;
        pos2 = pos4 - touch.clientY;
        pos3 = touch.clientX;
        pos4 = touch.clientY;
        
        const newTop = element.offsetTop - pos2;
        const newLeft = element.offsetLeft - pos1;
        
        element.style.top = newTop + "px";
        element.style.left = newLeft + "px";
        element.style.right = "auto";
        element.style.bottom = "auto";
      }

      function closeDragElement() {
        isDragging = false;
        element.classList.remove('dragging');
        document.onmouseup = null;
        document.onmousemove = null;
        document.ontouchend = null;
        document.ontouchmove = null;
      }
    }

    // Initialize map with higher max zoom
    const map = L.map("map", {
      maxZoom: 22
    }).setView([-33.4452, 150.1528], 15);
    
    // Base layers with increased maxZoom and maxNativeZoom
    const osmLayer = L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      maxZoom: 22,
      maxNativeZoom: 19,
      attribution: "© OpenStreetMap contributors"
    });

    const nswTopoLayer = L.esri.tiledMapLayer({
      url: 'https://maps.six.nsw.gov.au/arcgis/rest/services/public/NSW_Topo_Map/MapServer',
      attribution: '© NSW Spatial Services',
      maxZoom: 22,
      maxNativeZoom: 16,
      opacity: 1
    });

    const nswImageryLayer = L.esri.tiledMapLayer({
      url: 'https://maps.six.nsw.gov.au/arcgis/rest/services/public/NSW_Imagery/MapServer',
      attribution: '© NSW Spatial Services',
      maxZoom: 22,
      maxNativeZoom: 18,
      opacity: 1
    });

    // Google Satellite imagery
    const worldImageryGoogle = L.tileLayer('https://mt1.google.com/vt/lyrs=s&x={x}&y={y}&z={z}', {
      attribution: '© Google',
      maxZoom: 22,
      maxNativeZoom: 20
    });

    // Add NSW Topo as default
    nswTopoLayer.addTo(map);
    let currentBaseLayer = nswTopoLayer;

    // Layer control with only the required maps
    const baseLayers = {
      "NSW Topographic": nswTopoLayer,
      "NSW Imagery": nswImageryLayer,
      "World Imagery (Google)": worldImageryGoogle,
      "OpenStreetMap": osmLayer
    };

    const layerControl = L.control.layers(baseLayers, null, {
      position: 'topleft'
    }).addTo(map);

    // Add zoom level display
    const currentZoomSpan = document.getElementById('current-zoom');
    map.on('zoomend', function() {
      currentZoomSpan.textContent = map.getZoom();
      drawGridLines();
    });

    // Redraw grid lines when map moves
    map.on('moveend', function() {
      drawGridLines();
    });

    // Grid toggle control
    const gridToggle = document.getElementById('grid-toggle');
    gridToggle.addEventListener('change', function() {
      toggleGridLines();
    });

    // 100m grid toggle control
    const grid100mToggle = document.getElementById('grid-100m-toggle');
    grid100mToggle.addEventListener('change', function() {
      toggle100mGrid();
    });

    // Opacity control
    const opacitySlider = document.getElementById('opacity-slider');
    const opacityValue = document.getElementById('opacity-value');

    opacitySlider.addEventListener('input', function() {
      const opacity = parseFloat(this.value);
      currentBaseLayer.setOpacity(opacity);
      opacityValue.textContent = Math.round(opacity * 100) + '%';
    });

    // Update current base layer when user switches
    map.on('baselayerchange', function(e) {
      currentBaseLayer = e.layer;
      const opacity = parseFloat(opacitySlider.value);
      currentBaseLayer.setOpacity(opacity);
    });

    // Device colors - expanded for 30 devices with unique, vibrant colors
    const deviceColors = {
      // Numeric IDs (1-30)
      '1': '#E74C3C',   '2': '#3498DB',   '3': '#2ECC71',   '4': '#F39C12',   '5': '#9B59B6',
      '6': '#1ABC9C',   '7': '#E67E22',   '8': '#34495E',   '9': '#E91E63',   '10': '#FF5722',
      '11': '#795548',  '12': '#607D8B',  '13': '#FF9800',  '14': '#4CAF50',  '15': '#673AB7',
      '16': '#FF1744',  '17': '#448AFF',  '18': '#00E676',  '19': '#FFC107',  '20': '#AB47BC',
      '21': '#26C6DA',  '22': '#FF6F00',  '23': '#546E7A',  '24': '#EC407A',  '25': '#8BC34A',
      '26': '#5E35B1',  '27': '#FF5252',  '28': '#00BCD4',  '29': '#FFEB3B',  '30': '#795548',
      
      // Roman numerals (I-XXX)
      'I': '#E74C3C',     'II': '#3498DB',    'III': '#2ECC71',   'IV': '#F39C12',    'V': '#9B59B6',
      'VI': '#1ABC9C',    'VII': '#E67E22',   'VIII': '#34495E',  'IX': '#E91E63',    'X': '#FF5722',
      'XI': '#795548',    'XII': '#607D8B',   'XIII': '#FF9800',  'XIV': '#4CAF50',   'XV': '#673AB7',
      'XVI': '#FF1744',   'XVII': '#448AFF',  'XVIII': '#00E676', 'XIX': '#FFC107',   'XX': '#AB47BC',
      'XXI': '#26C6DA',   'XXII': '#FF6F00',  'XXIII': '#546E7A', 'XXIV': '#EC407A',  'XXV': '#8BC34A',
      'XXVI': '#5E35B1',  'XXVII': '#FF5252', 'XXVIII': '#00BCD4','XXIX': '#FFEB3B',  'XXX': '#795548'
    };

    // Initialize socket connection
    const socket = io({ 
      transports: ['websocket'],
      timeout: 5000,
      forceNew: true
    });
    
    // Debug elements
    const socketStatus = document.getElementById('socket-status');
    const deviceCount = document.getElementById('device-count');
    const pointCount = document.getElementById('point-count');
    const rejectedCount = document.getElementById('rejected-count');
    const lastUpdate = document.getElementById('last-update');
    
    let totalPoints = 0;

    // Socket connection handlers
    socket.on('connect', () => {
      console.log('✅ Socket connected');
      socketStatus.textContent = '✅';
      socketStatus.style.color = '#2ECC71';
    });

    socket.on('disconnect', () => {
      console.log('❌ Socket disconnected');
      socketStatus.textContent = '❌';
      socketStatus.style.color = '#E74C3C';
    });

    socket.on('connect_error', (error) => {
      console.error('Socket connection error:', error);
      socketStatus.textContent = '⚠️';
      socketStatus.style.color = '#F39C12';
    });

    const gpsTrails = {};
    const packetCounts = {};
    const latestPackets = {};
    const allPointsBounds = L.latLngBounds();
    const allMarkers = {};
    const trailLayers = {};
    const deviceVisibility = {};
    let selectedDevice = null;
    let hasInitialData = false;

    function toggleDeviceVisibility(deviceId) {
      if (selectedDevice === deviceId) {
        selectedDevice = null;
        showAllDevices();
      } else {
        selectedDevice = deviceId;
        hideAllDevicesExcept(deviceId);
      }
    }

    function showAllDevices() {
      Object.keys(allMarkers).forEach(deviceId => {
        deviceVisibility[deviceId] = true;
        showDeviceMarkers(deviceId);
      });
    }

    function hideAllDevicesExcept(keepDeviceId) {
      Object.keys(allMarkers).forEach(deviceId => {
        if (deviceId === keepDeviceId) {
          deviceVisibility[deviceId] = true;
          showDeviceMarkers(deviceId);
        } else {
          deviceVisibility[deviceId] = false;
          hideDeviceMarkers(deviceId);
        }
      });
    }

    function showDeviceMarkers(deviceId) {
      if (allMarkers[deviceId] && allMarkers[deviceId].current) {
        allMarkers[deviceId].current.circle.addTo(map);
        allMarkers[deviceId].current.label.addTo(map);
      }
      
      if (allMarkers[deviceId] && allMarkers[deviceId].history) {
        allMarkers[deviceId].history.forEach(marker => {
          marker.addTo(map);
        });
      }
      
      if (trailLayers[deviceId]) {
        trailLayers[deviceId].forEach(layer => {
          layer.addTo(map);
        });
      }
    }

    function hideDeviceMarkers(deviceId) {
      if (allMarkers[deviceId] && allMarkers[deviceId].current) {
        map.removeLayer(allMarkers[deviceId].current.circle);
        map.removeLayer(allMarkers[deviceId].current.label);
      }
      
      if (allMarkers[deviceId] && allMarkers[deviceId].history) {
        allMarkers[deviceId].history.forEach(marker => {
          map.removeLayer(marker);
        });
      }
      
      if (trailLayers[deviceId]) {
        trailLayers[deviceId].forEach(layer => {
          map.removeLayer(layer);
        });
      }
    }

    function addDataPoint(point, isLatest = false) {
      const lat = parseFloat(point.latitude);
      const lon = parseFloat(point.longitude);
      
      // Validate coordinates
      if (isNaN(lat) || isNaN(lon) || lat < -90 || lat > 90 || lon < -180 || lon > 180) {
        console.warn('Invalid coordinates:', point);
        return;
      }

      const color = deviceColors[point.device_id] || "#7F8C8D";
      const gridRef = latLonToGridReference(lat, lon);
      console.log(`Adding point for ${point.device_id}: (${lat}, ${lon}), Grid: ${gridRef}, isLatest: ${isLatest}`);

      if (isLatest) {
        const circle = L.circleMarker([lat, lon], {
          radius: 10,
          color: color,
          fillColor: color,
          fillOpacity: 0.7,
          weight: 3
        });

        const popupContent = `
          <strong>Device ID:</strong> ${point.device_id}<br>
          <strong>Grid Reference:</strong> ${gridRef}<br>
          <strong>Lat/Lon:</strong> ${lat.toFixed(6)}, ${lon.toFixed(6)}<br>
          <strong>Timestamp:</strong> ${point.timestamp}<br>
          <strong>Satellites:</strong> ${point.sats || 'N/A'}
        `;
        circle.bindPopup(popupContent);

        const label = L.divIcon({
          html: `<div style="color: ${color}; font-weight: bold; text-shadow: 1px 1px 2px white;">${point.device_id}</div>`,
          className: 'device-label',
          iconSize: [20, 20]
        });

        const labelMarker = L.marker([lat, lon], { icon: label, interactive: false });
        
        if (!allMarkers[point.device_id]) allMarkers[point.device_id] = { current: null, history: [] };
        
        if (allMarkers[point.device_id].current) {
          map.removeLayer(allMarkers[point.device_id].current.circle);
          map.removeLayer(allMarkers[point.device_id].current.label);
        }
        
        allMarkers[point.device_id].current = { circle, label: labelMarker };
        
        // Add to map if device is visible
        if (deviceVisibility[point.device_id] !== false) {
          circle.addTo(map);
          labelMarker.addTo(map);
        }
        
        totalPoints++;
        
      } else {
        const isFirstPoint = !allMarkers[point.device_id] || allMarkers[point.device_id].history.length === 0;
        
        if (isFirstPoint) {
          const crestIcon = L.icon({
            iconUrl: "https://raw.githubusercontent.com/AnthonyMacks/gps_tracker/main/templates/scucrest.png",
            iconSize: [32, 32],
            iconAnchor: [16, 32],
            popupAnchor: [0, -32]
          });

          const crestMarker = L.marker([lat, lon], { 
            icon: crestIcon,
            interactive: true
          });

          const popupContent = `
            <strong>Device ID:</strong> ${point.device_id} (START)<br>
            <strong>Grid Reference:</strong> ${gridRef}<br>
            <strong>Lat/Lon:</strong> ${lat.toFixed(6)}, ${lon.toFixed(6)}<br>
            <strong>Timestamp:</strong> ${point.timestamp}
          `;
          crestMarker.bindPopup(popupContent);

          if (!allMarkers[point.device_id]) allMarkers[point.device_id] = { current: null, history: [] };
          allMarkers[point.device_id].history.push(crestMarker);
          
          if (deviceVisibility[point.device_id] !== false) {
            crestMarker.addTo(map);
          }
          
          totalPoints++;
        } else {
          const pinIcon = L.divIcon({
            html: `<div style="
              width: 12px; 
              height: 12px; 
              background-color: ${color}; 
              border: 2px solid white; 
              border-radius: 50%;
              box-shadow: 0 0 3px rgba(0,0,0,0.4);
            "></div>`,
            className: 'history-pin',
            iconSize: [16, 16],
            iconAnchor: [8, 8]
          });

          const pin = L.marker([lat, lon], { 
            icon: pinIcon,
            interactive: true
          });

          const popupContent = `
            <strong>Device ID:</strong> ${point.device_id}<br>
            <strong>Grid Reference:</strong> ${gridRef}<br>
            <strong>Lat/Lon:</strong> ${lat.toFixed(6)}, ${lon.toFixed(6)}<br>
            <strong>Timestamp:</strong> ${point.timestamp}
          `;
          pin.bindPopup(popupContent);

          if (!allMarkers[point.device_id]) allMarkers[point.device_id] = { current: null, history: [] };
          allMarkers[point.device_id].history.push(pin);
          
          if (deviceVisibility[point.device_id] !== false) {
            pin.addTo(map);
          }
          
          totalPoints++;
        }
      }
    }

    function drawTrail(device_id) {
      const trail = gpsTrails[device_id];
      if (!trail || trail.length < 2) return;
      
      const color = deviceColors[device_id] || "#7F8C8D";

      if (trailLayers[device_id]) {
        trailLayers[device_id].forEach(layer => {
          if (map.hasLayer(layer)) {
            map.removeLayer(layer);
          }
        });
      }
      trailLayers[device_id] = [];

      const polyline = L.polyline(trail, {
        color: color,
        weight: 4,
        opacity: 0.8,
        className: 'animated-polyline'
      });
      
      trailLayers[device_id].push(polyline);
      
      if (deviceVisibility[device_id] !== false) {
        polyline.addTo(map);
      }

      console.log(`Trail drawn for device ${device_id} with ${trail.length} points`);
    }

    function getAgeLabel(ts) {
      const iso = ts.replace(" ", "T") + "Z";
      const pingTime = new Date(iso);
      if (isNaN(pingTime)) {
        console.warn("Bad timestamp:", ts);
        return "——";
      }

      const nowSec = Date.now();
      const diffSec = Math.floor((nowSec - pingTime.getTime()) / 1000);
      if (diffSec < 60)   return `${diffSec}s ago`;
      if (diffSec < 3600) return `${Math.floor(diffSec/60)}m ago`;
      return `${Math.floor(diffSec/3600)}h ago`;
    }

    function getRowClass(ts, sats) {
      const pingTime = new Date(ts);
      const now = new Date();
      const diff = (now - pingTime) / 1000;

      if (sats !== undefined && sats < 4) return "row-low-sats";

      if (diff <= 180) return "row-active";
      if (diff <= 360) return "row-warm";
      return "row-stale";
    }

    function updateTable() {
      const tbody1 = document.querySelector("#device-table tbody");
      const tbody2 = document.querySelector("#device-table2 tbody");
      tbody1.innerHTML = "";
      tbody2.innerHTML = "";

      const sortedIDs = Object.keys(latestPackets).sort((a, b) =>
        a.localeCompare(b, 'en', { sensitivity: 'base', numeric: true })
      );

      // Devices I-XII go to first table, XIII-XXX go to second table
      const firstTableDevices = ['I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX', 'X', 'XI', 'XII'];
      const secondTableDevices = ['XIII', 'XIV', 'XV', 'XVI', 'XVII', 'XVIII', 'XIX', 'XX', 'XXI', 'XXII', 'XXIII', 'XXIV', 'XXV', 'XXVI', 'XXVII', 'XXVIII', 'XXIX', 'XXX'];

      for (const id of sortedIDs) {
        const packet = latestPackets[id];
        const count  = packetCounts[id] || 0;
        const sats   = packet.sats ?? "—";
        const lat    = parseFloat(packet.latitude);
        const lon    = parseFloat(packet.longitude);
        const gridRef = latLonToGridReference(lat, lon);

        const row = document.createElement("tr");
        row.className = getRowClass(packet.timestamp, packet.sats);

        row.innerHTML = `
          <td>${id}</td>
          <td>${gridRef}</td>
          <td>${count}</td>
          <td>${sats}</td>
        `;

        row.style.cursor = "pointer";
        row.addEventListener("click", () => {
          toggleDeviceVisibility(id);
          updateTable();
        });

        if (selectedDevice === id) {
          row.style.border = "2px solid #3498DB";
        }

        // Add row to appropriate table
        if (firstTableDevices.includes(id)) {
          tbody1.appendChild(row);
        } else if (secondTableDevices.includes(id)) {
          tbody2.appendChild(row);
        }
      }
    }

    function updateDebugInfo() {
      deviceCount.textContent = Object.keys(latestPackets).length;
      pointCount.textContent = totalPoints;
      rejectedCount.textContent = rejectedPointsCount;
      lastUpdate.textContent = new Date().toLocaleTimeString();
    }
    
    function processGPSUpdate(data) {
      console.log('📡 Processing GPS update:', data);
      
      const { latitude, longitude, device_id, timestamp } = data;
      if (!latitude || !longitude || !device_id || !timestamp) {
        console.warn('Missing required data:', data);
        return;
      }

      const lat = parseFloat(latitude);
      const lon = parseFloat(longitude);
      
      if (isNaN(lat) || isNaN(lon)) {
        console.warn('Invalid coordinates:', data);
        return;
      }

      // Validate distance from start point
      if (!isValidDistance(device_id, lat, lon)) {
        updateDebugInfo();
        return;
      }

      // Store the packet with corrected timestamp
      latestPackets[device_id] = {
        ...data,
        timestamp: timestamp.replace(" ", "T") + "Z"
      };

      packetCounts[device_id] = (packetCounts[device_id] || 0) + 1;

      // Move the last "current" point into history
      if (gpsTrails[device_id] && gpsTrails[device_id].length) {
        const lastPoint = {
          ...latestPackets[device_id],
          latitude: gpsTrails[device_id][gpsTrails[device_id].length - 1][0],
          longitude: gpsTrails[device_id][gpsTrails[device_id].length - 1][1]
        };
        addDataPoint(lastPoint, false);
      }
      
      // Add the new current marker
      addDataPoint(data, true);

      // Update map bounds
      allPointsBounds.extend([lat, lon]);
      
      // Only fit bounds on first data
      if (!hasInitialData) {
        map.fitBounds(allPointsBounds, { padding: [30, 30], maxZoom: 16 });
        hasInitialData = true;
      }

      // Build the trail
      gpsTrails[device_id] = gpsTrails[device_id] || [];
      gpsTrails[device_id].push([lat, lon]);
      if (gpsTrails[device_id].length > 100) gpsTrails[device_id].shift();

      // Redraw trail
      drawTrail(device_id);

      // Update UI
      updateTable();
      updateDebugInfo();

      console.log(`📍 ${device_id} → Grid: ${latLonToGridReference(lat, lon)} | count=${packetCounts[device_id]}`);
    }

    // Initialize
    console.log('Initializing GPS tracker...');
    
    // Make info panels draggable
    makeDraggable(document.getElementById('info'));
    makeDraggable(document.getElementById('info2'));
    
    // Test grid conversion with known coordinates
    console.log('=== Testing Grid Conversion ===');
    const testLat = -33.451338;
    const testLon = 150.138327;
    console.log(`Test coords: ${testLat}, ${testLon}`);
    console.log('Expected: 56H KH 34001 95014');
    console.log('Expected 8-figure: 56KH 3400 9501');
    
    // Get zone
    const testZone = getUTMZone(testLon);
    console.log(`Calculated Zone: ${testZone}`);
    
    // Test with GDA94 Zone 56
    const utmGDA94_56 = proj4('EPSG:4326', 'EPSG:28356', [testLon, testLat]);
    console.log(`GDA94 Zone 56 UTM: E=${utmGDA94_56[0].toFixed(2)}, N=${utmGDA94_56[1].toFixed(2)}`);
    console.log(`  E100k=${Math.floor(utmGDA94_56[0]/100000)}, N100k=${Math.floor(utmGDA94_56[1]/100000)}`);
    
    // Test with GDA2020 Zone 56
    const utmGDA2020_56 = proj4('EPSG:4326', 'EPSG:7856', [testLon, testLat]);
    console.log(`GDA2020 Zone 56 UTM: E=${utmGDA2020_56[0].toFixed(2)}, N=${utmGDA2020_56[1].toFixed(2)}`);
    console.log(`  E100k=${Math.floor(utmGDA2020_56[0]/100000)}, N100k=${Math.floor(utmGDA2020_56[1]/100000)}`);
    
    // Test grid reference calculation
    useGDA94 = true;
    const testGridGDA94 = latLonToGridReference(testLat, testLon);
    console.log(`GDA94 Result: ${testGridGDA94}`);
    
    useGDA94 = false;
    const testGridGDA2020 = latLonToGridReference(testLat, testLon);
    console.log(`GDA2020 Result: ${testGridGDA2020}`);
    
    // Reset to GDA94 as default
    useGDA94 = true;
    console.log('===============================');
    
    // Draw initial grid lines
    setTimeout(() => {
      drawGridLines();
    }, 500);
    
    // Test grid conversion
    const testGrid = latLonToGridReference(-33.8688, 151.2093);
    console.log('Test grid conversion (Sydney):', testGrid);
    
    // Setup debug panel
    const debugPanel = document.getElementById('debug');
    let debugTimeout;
    
    debugPanel.classList.add('collapsed');
    
    debugPanel.addEventListener('mouseenter', () => {
      clearTimeout(debugTimeout);
      debugPanel.classList.remove('collapsed');
    });
    
    debugPanel.addEventListener('mouseleave', () => {
      debugTimeout = setTimeout(() => {
        debugPanel.classList.add('collapsed');
      }, 1500);
    });
    
    debugPanel.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      clearTimeout(debugTimeout);
      
      if (debugPanel.classList.contains('collapsed')) {
        debugPanel.classList.remove('collapsed');
        debugTimeout = setTimeout(() => {
          debugPanel.classList.add('collapsed');
        }, 4000);
      } else {
        debugPanel.classList.add('collapsed');
      }
    });
    
    // Initialize socket connection
    socket.on("gps_update", (data) => {
      processGPSUpdate(data);
    });

    setInterval(updateTable, 10000);
    
    document.getElementById("build-time").textContent =
      new Date().toLocaleString("en-AU", {
        timeZone: "Australia/Sydney",
        hour12: false,
        year: 'numeric',
        month: 'short',
        day: 'numeric',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit'
      });
  </script>
</body>
</html>

