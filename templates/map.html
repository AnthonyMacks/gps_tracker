<!DOCTYPE html>

<html>
<head><style>
.lower-right-image {
    position: absolute;
    bottom: 20px;
    right: 20px;
    max-width: 120px;
    z-index: 1000;
}

</style>
<title>Live GPS Tracker v1.9 - NSW Topo + World Imagery</title>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" name="viewport"/>
<link href="https://unpkg.com/leaflet/dist/leaflet.css" rel="stylesheet"/>
<style>
    body, html { margin: 0; padding: 0; height: 100%; }
    #map { height: 100%; width: 100%; z-index: 0; }

    #info {
      position: absolute;
      top: 10px;
      right: 10px;
      max-width: 340px;
      max-height: 70%;
      overflow-y: auto;
      background: rgba(255,255,255,0.85);
      padding: 10px;
      border-radius: 8px;
      font-family: sans-serif;
      font-size: 13px;
      color: #2C3E50;
      box-shadow: 0 0 6px rgba(0,0,0,0.2);
      z-index: 1001;
      cursor: move;
      user-select: none;
    }

    #info2 {
      position: absolute;
      top: 10px;
      right: 370px;
      max-width: 340px;
      max-height: 70%;
      overflow-y: auto;
      background: rgba(255,255,255,0.85);
      padding: 10px;
      border-radius: 8px;
      font-family: sans-serif;
      font-size: 13px;
      color: #2C3E50;
      box-shadow: 0 0 6px rgba(0,0,0,0.2);
      z-index: 1001;
      cursor: move;
      user-select: none;
    }

    #info.dragging, #info2.dragging {
      opacity: 0.8;
      cursor: grabbing;
    }

    #toggle-button, #toggle-button2 {
      background-color: #0078D7;
      color: white;
      border: none;
      padding: 8px 16px;
      font-size: 14px;
      border-radius: 4px;
      cursor: pointer;
      margin-bottom: 10px;
      width: 100%;
    }
    
    #toggle-button:hover, #toggle-button2:hover {
      background-color: #005A9E;
    }

    #opacity-control {
      position: absolute;
      bottom: 60px;
      left: 10px;
      background: rgba(255,255,255,0.9);
      padding: 10px;
      border-radius: 6px;
      font-family: sans-serif;
      font-size: 12px;
      box-shadow: 0 0 6px rgba(0,0,0,0.2);
      z-index: 1001;
    }

    #opacity-control label {
      display: block;
      margin-bottom: 5px;
      font-weight: bold;
    }

    #opacity-control input[type="range"] {
      width: 150px;
      margin-right: 10px;
    }

    #grid-control {
      position: absolute;
      bottom: 120px;
      left: 10px;
      background: rgba(255,255,255,0.9);
      padding: 10px;
      border-radius: 6px;
      font-family: sans-serif;
      font-size: 12px;
      box-shadow: 0 0 6px rgba(0,0,0,0.2);
      z-index: 1001;
    }

    #grid-control label {
      display: flex;
      align-items: center;
      cursor: pointer;
    }

    #grid-control input[type="checkbox"] {
      margin-right: 8px;
      cursor: pointer;
    }

    .grid-label-marker {
      background: transparent !important;
      border: none !important;
    }

    .row-active { background-color: #D5F5E3; }
    .row-warm   { background-color: #FCF3CF; }
    .row-stale  { background-color: #FADBD8; }

    .row-low-sats {
      background-color: #F5B7B1 !important;
      animation: blink 1s step-start infinite;
    }

    @keyframes blink {
      50% { background-color: #FADBD8; }
    }

    .device-label {
      background: transparent;
      color: black;
      font-weight: bold;
      text-align: center;
      line-height: 24px;
      font-size: 11px;
    }

    footer {
      position: absolute;
      bottom: 10px;
      left: 10px;
      font-size: 12px;
      color: #666;
      font-family: sans-serif;
      background-color: rgba(255,255,255,0.6);
      padding: 4px 8px;
      border-radius: 6px;
      z-index: 1001;
    }

    #export-control {
      position: absolute;
      bottom: 20px;
      right: 150px;
      z-index: 1001;
    }

    .export-dropdown {
      position: relative;
      display: inline-block;
    }

    .export-btn {
      background-color: #27AE60;
      color: white;
      padding: 10px 16px;
      font-size: 13px;
      font-family: sans-serif;
      font-weight: bold;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      box-shadow: 0 2px 5px rgba(0,0,0,0.3);
      transition: background-color 0.3s ease;
    }

    .export-btn:hover {
      background-color: #229954;
    }

    .export-dropdown-content {
      display: none;
      position: absolute;
      bottom: 100%;
      right: 0;
      margin-bottom: 5px;
      background-color: rgba(255,255,255,0.98);
      min-width: 200px;
      max-height: 400px;
      overflow-y: auto;
      box-shadow: 0 4px 8px rgba(0,0,0,0.3);
      border-radius: 6px;
      z-index: 1002;
    }

    .export-dropdown:hover .export-dropdown-content {
      display: block;
    }

    .export-option {
      color: #333;
      padding: 10px 16px;
      text-decoration: none;
      display: block;
      font-family: sans-serif;
      font-size: 13px;
      cursor: pointer;
      border-bottom: 1px solid #eee;
      transition: background-color 0.2s ease;
    }

    .export-option:last-child {
      border-bottom: none;
    }

    .export-option:hover {
      background-color: #E8F5E9;
    }

    .export-option.all-devices {
      background-color: #F0F8FF;
      font-weight: bold;
      border-bottom: 2px solid #3498DB;
    }

    .export-option.all-devices:hover {
      background-color: #D6EAF8;
    }

    .export-option.clear-data {
      background-color: #FFEBEE;
      font-weight: bold;
      border-top: 2px solid #E74C3C;
      color: #C0392B;
    }

    .export-option.clear-data:hover {
      background-color: #FFCDD2;
    }

    .export-section-header {
      padding: 8px 16px;
      background-color: #ECF0F1;
      font-weight: bold;
      font-size: 11px;
      color: #7F8C8D;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    @keyframes pulse {
      0%   { background-color: #D5F5E3; }
      50%  { background-color: #ABEBC6; }
      100% { background-color: #D5F5E3; }
    }

    .row-active {
      animation: pulse 2s infinite;
    }

    #debug {
      position: absolute;
      bottom: 160px;
      right: 10px;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 10px;
      border-radius: 6px;
      font-family: monospace;
      font-size: 11px;
      max-width: 300px;
      z-index: 1001;
      transition: all 0.3s ease;
      cursor: pointer;
      height: auto;
      min-height: 20px;
    }

    #debug.collapsed {
      height: 25px;
      padding: 5px 10px;
      overflow: hidden;
    }

    #debug .debug-content {
      transition: all 0.3s ease;
      opacity: 1;
      max-height: 200px;
    }

    #debug.collapsed .debug-content {
      opacity: 0;
      max-height: 0;
      margin-top: -5px;
    }

    #debug .debug-title {
      font-weight: bold;
      margin-bottom: 5px;
      font-size: 11px;
    }

    #debug.collapsed .debug-title {
      margin-bottom: 0;
      font-size: 10px;
    }

    .animated-polyline {
      stroke-dasharray: 1, 14;
      stroke-linecap: round;
      animation: moveDots 4s linear infinite;
    }

    @keyframes moveDots {
      0% {
        stroke-dashoffset: 15;
      }
      100% {
        stroke-dashoffset: 0;
      }
    }

    table {
      width: 100%;
      border-collapse: collapse;
      margin: 0 auto;
    }
    
    th, td {
      border: 1px solid #ddd;
      padding: 12px;
      text-align: center;
    }
    
    th {
      background-color: #f8f9fa;
      font-weight: bold;
      color: #333;
      position: sticky;
      top: 0;
    }
    
    tr:nth-child(even) {
      background-color: #f9f9f9;
    }
    
    tr:hover {
      background-color: #e6f3ff;
    }

    .hidden {
      display: none;
    }

    .row-number {
      background-color: #e9ecef;
      font-weight: bold;
    }

    @media (max-width: 768px) {
      #info {
        max-width: none;
        width: calc(45% - 10px);
        max-height: 35%;
        font-size: 11px;
        padding: 6px;
      }

      #info2 {
        max-width: none;
        width: calc(45% - 10px);
        max-height: 35%;
        font-size: 11px;
        padding: 6px;
      }

      #info strong, #info2 strong {
        font-size: 12px;
      }

      table {
        font-size: 10px;
      }

      th, td {
        padding: 4px 2px;
      }

      #toggle-button, #toggle-button2 {
        font-size: 12px;
        padding: 6px 12px;
      }

      #opacity-control {
        bottom: 60px;
        left: 10px;
        font-size: 10px;
        padding: 6px;
      }

      #grid-control {
        bottom: 110px;
        left: 10px;
        font-size: 10px;
        padding: 6px;
      }

      #debug {
        bottom: 140px;
        left: 10px;
        font-size: 9px;
        padding: 6px;
        max-width: 200px;
      }

      #debug.collapsed {
        height: 22px;
        padding: 4px 6px;
      }

      #debug .debug-title {
        font-size: 9px;
      }

      #debug.collapsed .debug-title {
        font-size: 8px;
      }

      footer {
        bottom: 10px;
        left: 10px;
        font-size: 10px;
        padding: 2px 4px;
      }

      #export-control {
        bottom: 45px;
        right: 10px;
      }

      .export-btn {
        padding: 8px 12px;
        font-size: 11px;
      }

      .export-dropdown-content {
        min-width: 180px;
        max-height: 300px;
      }

      .export-option {
        padding: 8px 12px;
        font-size: 11px;
      }
    }

    @media (max-width: 480px) and (orientation: portrait) {
      #info {
        max-height: 30%;
        font-size: 10px;
        width: calc(48% - 10px);
      }

      #info2 {
        max-height: 30%;
        font-size: 10px;
        width: calc(48% - 10px);
      }

      table {
        font-size: 9px;
      }

      th, td {
        padding: 3px 1px;
      }

      #toggle-button, #toggle-button2 {
        font-size: 11px;
        padding: 5px 10px;
      }

      #opacity-control {
        bottom: 60px;
        left: 10px;
        font-size: 9px;
        padding: 4px;
      }

      #grid-control {
        bottom: 100px;
        left: 10px;
        font-size: 9px;
        padding: 4px;
      }

      #grid-control button {
        font-size: 7px;
        padding: 1px 3px;
      }

      #debug {
        bottom: 130px;
        right: 10px;
        left: auto;
        font-size: 8px;
        padding: 4px;
        max-width: 150px;
      }

      #debug.collapsed {
        height: 18px;
        padding: 3px 4px;
      }

      #debug .debug-title {
        font-size: 8px;
      }

      #debug.collapsed .debug-title {
        font-size: 7px;
      }

      footer {
        font-size: 9px;
      }

      #export-control {
        bottom: 40px;
        right: 10px;
      }

      .export-btn {
        padding: 6px 10px;
        font-size: 10px;
      }

      .export-dropdown-content {
        min-width: 160px;
        max-height: 250px;
      }

      .export-option {
        padding: 7px 10px;
        font-size: 10px;
      }

      .lower-right-image {
        max-width: 80px;
      }
    }

    @media (max-width: 768px) and (orientation: landscape) {
      #info {
        width: 220px;
        max-width: 220px;
        max-height: 40%;
      }

      #info2 {
        width: 220px;
        max-width: 220px;
        max-height: 40%;
      }

      #opacity-control {
        bottom: 10px;
        left: 10px;
        font-size: 10px;
      }

      #grid-control {
        bottom: 50px;
        left: 10px;
        font-size: 10px;
      }

      #debug {
        bottom: 140px;
        right: 10px;
        left: auto;
        font-size: 9px;
        max-width: 180px;
      }

      #debug.collapsed {
        height: 20px;
        padding: 4px 6px;
      }

      #debug .debug-title {
        font-size: 9px;
      }

      #debug.collapsed .debug-title {
        font-size: 8px;
      }

      #export-control {
        bottom: 10px;
        right: 150px;
      }

      .export-btn {
        padding: 7px 11px;
        font-size: 11px;
      }
    }

    #playback-control {
      position: absolute;
      bottom: 80px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.85);
      padding: 15px 20px;
      border-radius: 10px;
      font-family: sans-serif;
      color: white;
      z-index: 1001;
      min-width: 500px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.5);
      display: none;
    }

    #playback-control.active {
      display: block;
    }

    .playback-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
      border-bottom: 1px solid rgba(255,255,255,0.3);
      padding-bottom: 8px;
    }

    .playback-title {
      font-size: 14px;
      font-weight: bold;
      color: #3498DB;
    }

    .playback-close {
      background: #E74C3C;
      color: white;
      border: none;
      padding: 4px 10px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 11px;
    }

    .playback-close:hover {
      background: #C0392B;
    }

    .playback-controls {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 10px;
    }

    .playback-btn {
      background: #3498DB;
      color: white;
      border: none;
      padding: 8px 15px;
      border-radius: 5px;
      cursor: pointer;
      font-size: 12px;
      font-weight: bold;
      transition: background 0.2s;
    }

    .playback-btn:hover {
      background: #2980B9;
    }

    .playback-btn:disabled {
      background: #7F8C8D;
      cursor: not-allowed;
    }

    .playback-btn.playing {
      background: #E67E22;
    }

    .playback-speed {
      background: rgba(255,255,255,0.1);
      color: white;
      border: 1px solid rgba(255,255,255,0.3);
      padding: 6px 10px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 11px;
    }

    .playback-time {
      font-size: 11px;
      color: #ECF0F1;
      font-family: monospace;
      min-width: 200px;
    }

    .playback-slider-container {
      margin-top: 5px;
    }

    .playback-slider {
      width: 100%;
      height: 6px;
      border-radius: 3px;
      background: rgba(255,255,255,0.2);
      outline: none;
      -webkit-appearance: none;
    } 

    .playback-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: #3498DB;
      cursor: pointer;
    }

    .playback-slider::-moz-range-thumb {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: #3498DB;
      cursor: pointer;
      border: none;
    }

    #playback-toggle {
      position: absolute;
      bottom: 200px;
      left: 10px;
      background: rgba(52, 152, 219, 0.9);
      color: white;
      padding: 10px 15px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 12px;
      font-weight: bold;
      box-shadow: 0 2px 5px rgba(0,0,0,0.3);
      z-index: 1001;
    }

    #playback-toggle:hover {
      background: rgba(41, 128, 185, 0.9);
    }

    @media (max-width: 768px) {
       #playback-control {
        min-width: 90%;
        left: 5%;
        transform: none;
        bottom: 60px;
      }

      #playback-toggle {
        bottom: 100px;
        left: 10px;
        font-size: 10px;
        padding: 8px 12px;
      }
    }
    
  </style>
</head>
<body><img alt="SCU Crest" class="lower-right-image" src="https://raw.githubusercontent.com/AnthonyMacks/gps_tracker/main/templates/scucrest.png"/>
<div id="map"></div>
<div id="info">
<strong>üì° GPS MacksTrack Data (I-XII) <span style="float: right; cursor: move; font-size: 18px;">‚ò∞</span></strong>
<button id="toggle-button" onclick="toggleTable()">Hide Table</button>
<table id="device-table">
<thead>
<tr>
<th>ID</th>
<th>Grid Ref</th>
<th>Count</th>
<th>Sats</th>
</tr>
</thead>
<tbody></tbody>
</table>
</div>
<div id="info2">
<strong>üì° GPS MacksTrack Data (XIII-XXX) <span style="float: right; cursor: move; font-size: 18px;">‚ò∞</span></strong>
<button id="toggle-button2" onclick="toggleTable2()">Hide Table</button>
<table id="device-table2">
<thead>
<tr>
<th>ID</th>
<th>Grid Ref</th>
<th>Count</th>
<th>Sats</th>
</tr>
</thead>
<tbody></tbody>
</table>
</div>
<div id="opacity-control">
<label for="opacity-slider">Base Layer Opacity:</label>
<input id="opacity-slider" max="1" min="0.1" step="0.1" type="range" value="1"/>
<span id="opacity-value">100%</span>
</div>
<div id="grid-control">
<label>
  <input type="checkbox" id="grid-toggle" checked/>
  Show 1km Grid Lines
</label>
<br/>
<label style="margin-top: 5px;">
  <input type="checkbox" id="grid-100m-toggle"/>
  Show 100m Grid Lines
</label>
</div>
<div id="debug" class="collapsed">
<div class="debug-title">Debug Info</div>
<div class="debug-content">
    Connected: <span id="socket-status">‚ùå</span><br/>
    Total Devices: <span id="device-count">0</span><br/>
    Total Points: <span id="point-count">0</span><br/>
    Rejected Points: <span id="rejected-count">0</span><br/>
    Last Update: <span id="last-update">never</span><br/>
    Current Zoom: <span id="current-zoom">13</span><br/>
    Stored Points: <span id="stored-count">0</span>
    <button onclick="if(confirm('üîÑ Reset all storage and reload page?')) { localStorage.clear(); location.reload(); }" 
            style="background: #E74C3C; color: white; padding: 4px 8px; border: none; border-radius: 3px; cursor: pointer; font-size: 10px; margin-top: 5px; width: 100%;">
      üîÑ Reset Storage
    </button>

</div>
</div>
<footer>
    üöÄ Last Render Build: <span id="build-time">loading...</span>
</footer>

<button id="playback-toggle">‚ñ∂Ô∏è Playback Mode</button>

<div id="playback-control">
  <div class="playback-header">
    <span class="playback-title">üìπ Trail Playback</span>
    <button class="playback-close" onclick="closePlayback()">‚úï Close</button>
  </div>
  
  <div class="playback-controls">
    <button class="playback-btn" id="play-btn" onclick="togglePlayback()">‚ñ∂Ô∏è Play</button>
    <button class="playback-btn" onclick="restartPlayback()">‚èÆÔ∏è Restart</button>
    
    <select class="playback-speed" id="playback-speed" onchange="changePlaybackSpeed()">
      <option value="0.5">0.5x</option>
      <option value="1" selected>1x</option>
      <option value="2">2x</option>
      <option value="5">5x</option>
      <option value="10">10x</option>
    </select>
    
    <span class="playback-time" id="playback-time">00:00:00 / 00:00:00</span>
  </div>
  
  <div class="playback-slider-container">
    <input type="range" class="playback-slider" id="playback-slider" 
           min="0" max="100" value="0" oninput="seekPlayback(this.value)">
  </div>
</div>
    
<div id="export-control">
  <div class="export-dropdown">
    <button class="export-btn">üì• Export KML</button>
    <div class="export-dropdown-content">
      <div class="export-option all-devices" onclick="exportKML('all')">üì¶ Export All Devices</div>
      <div class="export-section-header">Individual Devices</div>
      <div class="export-option" onclick="exportKML('I')">Device I</div>
      <div class="export-option" onclick="exportKML('II')">Device II</div>
      <div class="export-option" onclick="exportKML('III')">Device III</div>
      <div class="export-option" onclick="exportKML('IV')">Device IV</div>
      <div class="export-option" onclick="exportKML('V')">Device V</div>
      <div class="export-option" onclick="exportKML('VI')">Device VI</div>
      <div class="export-option" onclick="exportKML('VII')">Device VII</div>
      <div class="export-option" onclick="exportKML('VIII')">Device VIII</div>
      <div class="export-option" onclick="exportKML('IX')">Device IX</div>
      <div class="export-option" onclick="exportKML('X')">Device X</div>
      <div class="export-option" onclick="exportKML('XI')">Device XI</div>
      <div class="export-option" onclick="exportKML('XII')">Device XII</div>
      <div class="export-option" onclick="exportKML('XIII')">Device XIII</div>
      <div class="export-option" onclick="exportKML('XIV')">Device XIV</div>
      <div class="export-option" onclick="exportKML('XV')">Device XV</div>
      <div class="export-option" onclick="exportKML('XVI')">Device XVI</div>
      <div class="export-option" onclick="exportKML('XVII')">Device XVII</div>
      <div class="export-option" onclick="exportKML('XVIII')">Device XVIII</div>
      <div class="export-option" onclick="exportKML('XIX')">Device XIX</div>
      <div class="export-option" onclick="exportKML('XX')">Device XX</div>
      <div class="export-option" onclick="exportKML('XXI')">Device XXI</div>
      <div class="export-option" onclick="exportKML('XXII')">Device XXII</div>
      <div class="export-option" onclick="exportKML('XXIII')">Device XXIII</div>
      <div class="export-option" onclick="exportKML('XXIV')">Device XXIV</div>
      <div class="export-option" onclick="exportKML('XXV')">Device XXV</div>
      <div class="export-option" onclick="exportKML('XXVI')">Device XXVI</div>
      <div class="export-option" onclick="exportKML('XXVII')">Device XXVII</div>
      <div class="export-option" onclick="exportKML('XXVIII')">Device XXVIII</div>
      <div class="export-option" onclick="exportKML('XXIX')">Device XXIX</div>
      <div class="export-option" onclick="exportKML('XXX')">Device XXX</div>
      <div class="export-section-header">Data Management</div>
      <div class="export-option clear-data" onclick="clearStoredData()">üóëÔ∏è Clear All Stored Data</div>
    </div>
  </div>
</div>
<script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
<script src="https://unpkg.com/esri-leaflet@3.0.10/dist/esri-leaflet.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.9.0/proj4.min.js"></script>
<script>
    proj4.defs("EPSG:7854", "+proj=utm +zone=54 +south +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs");
    proj4.defs("EPSG:7855", "+proj=utm +zone=55 +south +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs");
    proj4.defs("EPSG:7856", "+proj=utm +zone=56 +south +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs");
    proj4.defs("EPSG:28354", "+proj=utm +zone=54 +south +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs");
    proj4.defs("EPSG:28355", "+proj=utm +zone=55 +south +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs");
    proj4.defs("EPSG:28356", "+proj=utm +zone=56 +south +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs");

    const e100kLetters = "ABCDEFGHJKLMNPQRSTUVWXYZ";
    const n100kLetters = "ABCDEFGHJKLMNPQRSTUV";
    let useGDA94 = true;

    function getUTMZone(lon) {
      if (lon >= 144 && lon < 150) return 55;
      if (lon >= 150 && lon < 156) return 56;
      if (lon >= 156 && lon < 162) return 57;
      return 56;
    }
    
    function getEPSG(zone) {
      if (useGDA94) {
        return 28354 + (zone - 54);
      } else {
        return 7854 + (zone - 54);
      }
    }

    function get100kmGridSquare(easting, northing, zone) {
      const e100k = Math.floor(easting / 100000);
      const n100k = Math.floor(northing / 100000);
      
      let colStart;
      if (zone === 54) colStart = 16;
      else if (zone === 55) colStart = 0;
      else if (zone === 56) colStart = 9;
      else if (zone === 57) colStart = 18;
      else colStart = 0;
      
      const eIndex = (colStart + (e100k - 1)) % 24;
      const nIndex = (n100k) % 20;
      const gridSquare = e100kLetters[eIndex] + n100kLetters[nIndex];
      
      return gridSquare;
    }

    function latLonToGridReference(lat, lon) {
      try {
        const zone = getUTMZone(lon);
        const epsg = getEPSG(zone);
        
        const utm = proj4('EPSG:4326', `EPSG:${epsg}`, [lon, lat]);
        const easting = utm[0];
        const northing = utm[1];

        const gridSquare = get100kmGridSquare(easting, northing, zone);
        
        const eastingRemainder = Math.floor(easting % 100000);
        const northingRemainder = Math.floor(northing % 100000);
        
        const eastingStr = eastingRemainder.toString().padStart(5, '0').substring(0, 4);
        const northingStr = northingRemainder.toString().padStart(5, '0').substring(0, 4);
        
        return `${eastingStr} ${northingStr}`;
      } catch (error) {
        console.error('Grid conversion error:', error);
        return `${lat.toFixed(4)}, ${lon.toFixed(4)}`;
      }
    }

    let gridLinesVisible = true;
    let grid100mVisible = false;
    let gridLineLayer = null;
    let grid100mLayer = null;
    let gridLabelMarkers = [];

    function clearGridLines() {
      if (gridLineLayer) {
        map.removeLayer(gridLineLayer);
        gridLineLayer = null;
      }
      gridLabelMarkers.forEach(marker => map.removeLayer(marker));
      gridLabelMarkers = [];
    }

    function clearGrid100m() {
      if (grid100mLayer) {
        map.removeLayer(grid100mLayer);
        grid100mLayer = null;
      }
    }

    function drawGridLines() {
      if (!gridLinesVisible) return;

      clearGridLines();

      try {
        const bounds = map.getBounds();
        const center = map.getCenter();
        const zoom = map.getZoom();

        if (zoom < 12) {
          console.log('Zoom too low for grid display');
          return;
        }

        const lat = center.lat;
        const lon = center.lng;
        const zone = getUTMZone(lon);
        const epsg = getEPSG(zone);

        const sw = proj4('EPSG:4326', `EPSG:${epsg}`, [bounds.getWest(), bounds.getSouth()]);
        const ne = proj4('EPSG:4326', `EPSG:${epsg}`, [bounds.getEast(), bounds.getNorth()]);

        const minE = Math.floor(sw[0] / 1000) * 1000;
        const maxE = Math.ceil(ne[0] / 1000) * 1000;
        const minN = Math.floor(sw[1] / 1000) * 1000;
        const maxN = Math.ceil(ne[1] / 1000) * 1000;

        const gridInterval = zoom >= 15 ? 1000 : zoom >= 13 ? 2000 : 5000;

        const allLines = [];
        const labels = [];

        console.log(`Drawing grid for zone ${zone}, datum: GDA94, interval: ${gridInterval}m`);

        for (let e = minE; e <= maxE; e += gridInterval) {
          const line = [];
          for (let n = minN; n <= maxN; n += 250) {
            try {
              const ll = proj4(`EPSG:${epsg}`, 'EPSG:4326', [e, n]);
              line.push([ll[1], ll[0]]);
            } catch (err) {
              console.warn('Grid conversion error:', err);
            }
          }
          
          if (line.length > 1) {
            allLines.push(line);
          }
        }

        for (let n = minN; n <= maxN; n += gridInterval) {
          const line = [];
          for (let e = minE; e <= maxE; e += 250) {
            try {
              const ll = proj4(`EPSG:${epsg}`, 'EPSG:4326', [e, n]);
              line.push([ll[1], ll[0]]);
            } catch (err) {
              console.warn('Grid conversion error:', err);
            }
          }
          
          if (line.length > 1) {
            allLines.push(line);
          }
        }

        if (allLines.length > 0) {
          gridLineLayer = L.polyline(allLines, {
            color: '#ff0000',
            weight: 2,
            opacity: 0.7,
            interactive: false
          }).addTo(map);
        }

        console.log(`Drawing labels: minE=${minE}, maxE=${maxE}, minN=${minN}, maxN=${maxN}`);

        for (let e = minE; e <= maxE; e += gridInterval) {
          try {
            const labelN = maxN - (maxN - minN) * 0.15;
            const ll = proj4(`EPSG:${epsg}`, 'EPSG:4326', [e, labelN]);
            const eastingLabel = Math.floor((e % 100000) / 1000).toString().padStart(2, '0');
            
            labels.push({
              position: [ll[1], ll[0]],
              text: eastingLabel,
              color: '#ff0000'
            });
          } catch (err) {
            console.warn('Easting label error:', err);
          }
        }

        for (let n = minN; n <= maxN; n += gridInterval) {
          try {
            const labelE = minE + (maxE - minE) * 0.15;
            const ll = proj4(`EPSG:${epsg}`, 'EPSG:4326', [labelE, n]);
            const northingLabel = Math.floor((n % 100000) / 1000).toString().padStart(2, '0');
            
            labels.push({
              position: [ll[1], ll[0]],
              text: northingLabel,
              color: '#0000ff'
            });
          } catch (err) {
            console.warn('Northing label error:', err);
          }
        }

        console.log(`Total labels created: ${labels.length}`);

        labels.forEach(label => {
          const marker = L.marker(label.position, {
            icon: L.divIcon({
              className: 'grid-label-marker',
              html: `<div style="background: rgba(255,255,255,0.95); padding: 3px 6px; font-size: 11px; font-weight: bold; border: 2px solid ${label.color}; border-radius: 3px; box-shadow: 0 2px 4px rgba(0,0,0,0.4); white-space: nowrap; color: ${label.color};">${label.text}</div>`,
              iconSize: [30, 22],
              iconAnchor: [15, 11]
            }),
            interactive: false
          }).addTo(map);
          
          gridLabelMarkers.push(marker);
        });

        console.log(`Drew ${allLines.length} grid lines with ${labels.length} labels at zoom ${zoom}`);

        if (grid100mVisible) {
          draw100mGrid();
        }

      } catch (error) {
        console.error('Error drawing grid lines:', error);
      }
    }

    function draw100mGrid() {
      clearGrid100m();

      try {
        const bounds = map.getBounds();
        const center = map.getCenter();
        const zoom = map.getZoom();

        if (zoom < 13) {
          console.log('Zoom too low for 100m grid display');
          return;
        }

        const lat = center.lat;
        const lon = center.lng;
        const zone = getUTMZone(lon);
        const epsg = getEPSG(zone);

        const sw = proj4('EPSG:4326', `EPSG:${epsg}`, [bounds.getWest(), bounds.getSouth()]);
        const ne = proj4('EPSG:4326', `EPSG:${epsg}`, [bounds.getEast(), bounds.getNorth()]);

        const minE = Math.floor(sw[0] / 100) * 100;
        const maxE = Math.ceil(ne[0] / 100) * 100;
        const minN = Math.floor(sw[1] / 100) * 100;
        const maxN = Math.ceil(ne[1] / 100) * 100;

        const allLines = [];

        for (let e = minE; e <= maxE; e += 100) {
          if (e % 1000 === 0) continue;
          
          const line = [];
          for (let n = minN; n <= maxN; n += 50) {
            try {
              const ll = proj4(`EPSG:${epsg}`, 'EPSG:4326', [e, n]);
              line.push([ll[1], ll[0]]);
            } catch (err) {
              console.warn('100m grid conversion error:', err);
            }
          }
          
          if (line.length > 1) {
            allLines.push(line);
          }
        }

        for (let n = minN; n <= maxN; n += 100) {
          if (n % 1000 === 0) continue;
          
          const line = [];
          for (let e = minE; e <= maxE; e += 50) {
            try {
              const ll = proj4(`EPSG:${epsg}`, 'EPSG:4326', [e, n]);
              line.push([ll[1], ll[0]]);
            } catch (err) {
              console.warn('100m grid conversion error:', err);
            }
          }
          
          if (line.length > 1) {
            allLines.push(line);
          }
        }

        if (allLines.length > 0) {
          grid100mLayer = L.polyline(allLines, {
            color: '#3366cc',
            weight: 1,
            opacity: 0.4,
            dashArray: '4, 4',
            interactive: false
          }).addTo(map);
        }

      } catch (error) {
        console.error('Error drawing 100m grid lines:', error);
      }
    }

    function toggleGridLines() {
      gridLinesVisible = !gridLinesVisible;
      if (gridLinesVisible) {
        drawGridLines();
      } else {
        clearGridLines();
        clearGrid100m();
      }
    }

    function toggle100mGrid() {
      grid100mVisible = !grid100mVisible;
      if (grid100mVisible) {
        if (!gridLinesVisible) {
          gridLinesVisible = true;
          document.getElementById('grid-toggle').checked = true;
          drawGridLines();
        } else {
          draw100mGrid();
        }
      } else {
        clearGrid100m();
      }
    }

    const deviceStartPoints = {};
    const MAX_DISTANCE_KM = 5;
    let rejectedPointsCount = 0;

    function calculateDistance(lat1, lon1, lat2, lon2) {
      const R = 6371;
      const dLat = (lat2 - lat1) * Math.PI / 180;
      const dLon = (lon2 - lon1) * Math.PI / 180;
      const a = 
        Math.sin(dLat/2) * Math.sin(dLat/2) +
        Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * 
        Math.sin(dLon/2) * Math.sin(dLon/2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
      return R * c;
    }

    function isValidDistance(deviceId, lat, lon) {
      if (!deviceStartPoints[deviceId]) {
        deviceStartPoints[deviceId] = { lat: lat, lon: lon };
        console.log(`üìç Setting start point for device ${deviceId}: (${lat.toFixed(6)}, ${lon.toFixed(6)})`);
        return true;
      }

      const startPoint = deviceStartPoints[deviceId];
      const distance = calculateDistance(startPoint.lat, startPoint.lon, lat, lon);
      
      if (distance > MAX_DISTANCE_KM) {
        console.warn(`üö´ Rejecting point for device ${deviceId}: ${distance.toFixed(2)}km > ${MAX_DISTANCE_KM}km limit`);
        rejectedPointsCount++;
        return false;
      }
      
      return true;
    }

    const STORAGE_VERSION = '1.0';
    const VERSION_KEY = 'mackstrack_version';
    
    const STORAGE_KEYS = {
      GPS_TRAILS: 'mackstrack_gps_trails',
      PACKET_COUNTS: 'mackstrack_packet_counts',
      LATEST_PACKETS: 'mackstrack_latest_packets',
      DEVICE_START_POINTS: 'mackstrack_device_start_points',
      REJECTED_COUNT: 'mackstrack_rejected_count'
    };

    function saveToLocalStorage() {
      try {
        localStorage.setItem(VERSION_KEY, STORAGE_VERSION);  
        localStorage.setItem(STORAGE_KEYS.GPS_TRAILS, JSON.stringify(gpsTrails));
        localStorage.setItem(STORAGE_KEYS.PACKET_COUNTS, JSON.stringify(packetCounts));
        localStorage.setItem(STORAGE_KEYS.LATEST_PACKETS, JSON.stringify(latestPackets));
        localStorage.setItem(STORAGE_KEYS.DEVICE_START_POINTS, JSON.stringify(deviceStartPoints));
        localStorage.setItem(STORAGE_KEYS.REJECTED_COUNT, rejectedPointsCount.toString());
        console.log('üíæ Data saved to localStorage');
        updateStoredCount();
      } catch (error) {
        console.error('Error saving to localStorage:', error);
      }
    }

    function loadFromLocalStorage() {
      try {
        const storedVersion = localStorage.getItem(VERSION_KEY);
    
        // If version mismatch, clear everything
        if (storedVersion !== STORAGE_VERSION) {
          console.warn(`‚ö†Ô∏è Storage version mismatch (stored: ${storedVersion}, current: ${STORAGE_VERSION}). Clearing old data.`);
          localStorage.clear();
          localStorage.setItem(VERSION_KEY, STORAGE_VERSION);
          return false;
        }
    
        const trails = localStorage.getItem(STORAGE_KEYS.GPS_TRAILS);
        const counts = localStorage.getItem(STORAGE_KEYS.PACKET_COUNTS);
        const packets = localStorage.getItem(STORAGE_KEYS.LATEST_PACKETS);
        const startPoints = localStorage.getItem(STORAGE_KEYS.DEVICE_START_POINTS);
        const rejectedCount = localStorage.getItem(STORAGE_KEYS.REJECTED_COUNT);

        if (trails) {
          const loadedTrails = JSON.parse(trails);
          Object.assign(gpsTrails, loadedTrails);
        }

        if (counts) {
          const loadedCounts = JSON.parse(counts);
          Object.assign(packetCounts, loadedCounts);
        }

        if (packets) {
          const loadedPackets = JSON.parse(packets);
          Object.assign(latestPackets, loadedPackets);
        }

        if (startPoints) {
          const loadedStartPoints = JSON.parse(startPoints);
          Object.assign(deviceStartPoints, loadedStartPoints);
        }

        if (rejectedCount) {
          rejectedPointsCount = parseInt(rejectedCount) || 0;
        }

        restoreMapFromStorage();
        updateStoredCount();
        
        return true;
      } catch (error) {
        console.error('Error loading from localStorage:', error);
        return false;
      }
    }

    function clearStoredData() {
      if (confirm('‚ö†Ô∏è Are you sure you want to clear all stored GPS data? This cannot be undone!')) {
        try {
          localStorage.removeItem(STORAGE_KEYS.GPS_TRAILS);
          localStorage.removeItem(STORAGE_KEYS.PACKET_COUNTS);
          localStorage.removeItem(STORAGE_KEYS.LATEST_PACKETS);
          localStorage.removeItem(STORAGE_KEYS.DEVICE_START_POINTS);
          localStorage.removeItem(STORAGE_KEYS.REJECTED_COUNT);
          
          Object.keys(gpsTrails).forEach(key => delete gpsTrails[key]);
          Object.keys(packetCounts).forEach(key => delete packetCounts[key]);
          Object.keys(latestPackets).forEach(key => delete latestPackets[key]);
          Object.keys(deviceStartPoints).forEach(key => delete deviceStartPoints[key]);
          rejectedPointsCount = 0;
          totalPoints = 0;
          
          Object.keys(allMarkers).forEach(deviceId => {
            hideDeviceMarkers(deviceId);
          });
          Object.keys(allMarkers).forEach(key => delete allMarkers[key]);
          Object.keys(trailLayers).forEach(key => delete trailLayers[key]);
          
          updateTable();
          updateDebugInfo();
          updateStoredCount();
          
          alert('‚úÖ All stored data has been cleared!');
        } catch (error) {
          console.error('Error clearing localStorage:', error);
          alert('‚ùå Error clearing data: ' + error.message);
        }
      }
    }

    function restoreMapFromStorage() {
      console.log('üîÑ Restoring map from stored data...');
  
      try {
        let restoredCount = 0;
        let errorCount = 0;
    
        Object.keys(gpsTrails).forEach(deviceId => {
          const trail = gpsTrails[deviceId];
          if (!trail || !Array.isArray(trail) || trail.length === 0) return;
      
          trail.forEach((point, index) => {
            // Validate point format
            if (!Array.isArray(point) || point.length < 2) {
              console.warn(`‚ö†Ô∏è Invalid point format for ${deviceId}:`, point);
              errorCount++;
              return;
            }
        
            const lat = parseFloat(point[0]);
            const lon = parseFloat(point[1]);
        
            // Validate coordinates
            if (isNaN(lat) || isNaN(lon) || lat < -90 || lat > 90 || lon < -180 || lon > 180) {
              console.warn(`‚ö†Ô∏è Invalid coordinates for ${deviceId}:`, point);
              errorCount++;
              return;
            }
        
            const isLast = index === trail.length - 1;
            const packet = {
              device_id: deviceId,
              latitude: lat,
              longitude: lon,
              timestamp: latestPackets[deviceId]?.timestamp || new Date().toISOString(),
              sats: latestPackets[deviceId]?.sats
            };
        
            addDataPoint(packet, isLast);
            restoredCount++;
          });
      
          drawTrail(deviceId);
        });
    
        console.log(`‚úÖ Restored ${restoredCount} points, ${errorCount} errors skipped`);
    
        // If too many errors, clear storage and reload
        if (errorCount > 10) {
          console.error('‚ùå Too many errors in stored data. Clearing storage...');
          localStorage.clear();
          alert('‚ö†Ô∏è Stored GPS data was corrupted and has been cleared. The page will reload.');
          location.reload();
          return;
        }
    
        updateTable();
        updateDebugInfo();
    
        if (Object.keys(gpsTrails).length > 0) {
          Object.keys(gpsTrails).forEach(deviceId => {
            gpsTrails[deviceId].forEach(point => {
              if (Array.isArray(point) && point.length >= 2) {
                const lat = parseFloat(point[0]);
                const lon = parseFloat(point[1]);
                if (!isNaN(lat) && !isNaN(lon)) {
                  allPointsBounds.extend([lat, lon]);
                }
              }
            });
          });
      
          if (allPointsBounds.isValid()) {
            map.fitBounds(allPointsBounds, { padding: [30, 30], maxZoom: 16 });
            hasInitialData = true;
          }
        }
      } catch (error) {
        console.error('‚ùå Critical error restoring from storage:', error);
        console.warn('‚ö†Ô∏è Clearing corrupt storage and reloading...');
        localStorage.clear();
        alert('‚ö†Ô∏è Stored GPS data was corrupted and has been cleared. The page will reload.');
        location.reload();
      }
    }

    function updateStoredCount() {
      const storedCount = document.getElementById('stored-count');
      let totalStoredPoints = 0;
      Object.values(gpsTrails).forEach(trail => {
        totalStoredPoints += trail.length;
      });
      storedCount.textContent = totalStoredPoints;
    }

    function toggleTable() {
      const table = document.getElementById("device-table");
      const button = document.getElementById("toggle-button");
      
      if (table.style.display === "none") {
        table.style.display = "table";
        button.textContent = "Hide Table";
      } else {
        table.style.display = "none";
        button.textContent = "Show Table";
      }
    }

    function toggleTable2() {
      const table = document.getElementById("device-table2");
      const button = document.getElementById("toggle-button2");
      
      if (table.style.display === "none") {
        table.style.display = "table";
        button.textContent = "Hide Table";
      } else {
        table.style.display = "none";
        button.textContent = "Show Table";
      }
    }

    function makeDraggable(element) {
      let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
      let isDragging = false;

      element.onmousedown = dragMouseDown;
      element.ontouchstart = dragTouchStart;

      function dragMouseDown(e) {
        if (e.target.tagName === 'BUTTON' || e.target.tagName === 'INPUT' || 
            e.target.closest('table') || e.target.closest('button')) {
          return;
        }
        
        e.preventDefault();
        pos3 = e.clientX;
        pos4 = e.clientY;
        isDragging = true;
        element.classList.add('dragging');
        document.onmouseup = closeDragElement;
        document.onmousemove = elementDrag;
      }

      function dragTouchStart(e) {
        if (e.target.tagName === 'BUTTON' || e.target.tagName === 'INPUT' || 
            e.target.closest('table') || e.target.closest('button')) {
          return;
        }
        
        const touch = e.touches[0];
        pos3 = touch.clientX;
        pos4 = touch.clientY;
        isDragging = true;
        element.classList.add('dragging');
        document.ontouchend = closeDragElement;
        document.ontouchmove = elementDragTouch;
      }

      function elementDrag(e) {
        if (!isDragging) return;
        e.preventDefault();
        pos1 = pos3 - e.clientX;
        pos2 = pos4 - e.clientY;
        pos3 = e.clientX;
        pos4 = e.clientY;
        
        const newTop = element.offsetTop - pos2;
        const newLeft = element.offsetLeft - pos1;
        
        element.style.top = newTop + "px";
        element.style.left = newLeft + "px";
        element.style.right = "auto";
        element.style.bottom = "auto";
      }

      function elementDragTouch(e) {
        if (!isDragging) return;
        const touch = e.touches[0];
        pos1 = pos3 - touch.clientX;
        pos2 = pos4 - touch.clientY;
        pos3 = touch.clientX;
        pos4 = touch.clientY;
        
        const newTop = element.offsetTop - pos2;
        const newLeft = element.offsetLeft - pos1;
        
        element.style.top = newTop + "px";
        element.style.left = newLeft + "px";
        element.style.right = "auto";
        element.style.bottom = "auto";
      }

      function closeDragElement() {
        isDragging = false;
        element.classList.remove('dragging');
        document.onmouseup = null;
        document.onmousemove = null;
        document.ontouchend = null;
        document.ontouchmove = null;
      }
    }

    const map = L.map("map", {
      maxZoom: 22
    }).setView([-33.4452, 150.1528], 15);
    
    const osmLayer = L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      maxZoom: 22,
      maxNativeZoom: 19,
      attribution: "¬© OpenStreetMap contributors"
    });

    const nswTopoLayer = L.esri.tiledMapLayer({
      url: 'https://maps.six.nsw.gov.au/arcgis/rest/services/public/NSW_Topo_Map/MapServer',
      attribution: '¬© NSW Spatial Services',
      maxZoom: 22,
      maxNativeZoom: 16,
      opacity: 1
    });

    const nswImageryLayer = L.esri.tiledMapLayer({
      url: 'https://maps.six.nsw.gov.au/arcgis/rest/services/public/NSW_Imagery/MapServer',
      attribution: '¬© NSW Spatial Services',
      maxZoom: 22,
      maxNativeZoom: 18,
      opacity: 1
    });

    const worldImageryGoogle = L.tileLayer('https://mt1.google.com/vt/lyrs=s&x={x}&y={y}&z={z}', {
      attribution: '¬© Google',
      maxZoom: 22,
      maxNativeZoom: 20
    });

    nswTopoLayer.addTo(map);
    let currentBaseLayer = nswTopoLayer;

    const baseLayers = {
      "NSW Topographic": nswTopoLayer,
      "NSW Imagery": nswImageryLayer,
      "World Imagery (Google)": worldImageryGoogle,
      "OpenStreetMap": osmLayer
    };

    const layerControl = L.control.layers(baseLayers, null, {
      position: 'topleft'
    }).addTo(map);

    const currentZoomSpan = document.getElementById('current-zoom');
    map.on('zoomend', function() {
      currentZoomSpan.textContent = map.getZoom();
      drawGridLines();
    });

    map.on('moveend', function() {
      drawGridLines();
    });

    const gridToggle = document.getElementById('grid-toggle');
    gridToggle.addEventListener('change', function() {
      toggleGridLines();
    });

    const grid100mToggle = document.getElementById('grid-100m-toggle');
    grid100mToggle.addEventListener('change', function() {
      toggle100mGrid();
    });

    const opacitySlider = document.getElementById('opacity-slider');
    const opacityValue = document.getElementById('opacity-value');

    opacitySlider.addEventListener('input', function() {
      const opacity = parseFloat(this.value);
      currentBaseLayer.setOpacity(opacity);
      opacityValue.textContent = Math.round(opacity * 100) + '%';
    });

    map.on('baselayerchange', function(e) {
      currentBaseLayer = e.layer;
      const opacity = parseFloat(opacitySlider.value);
      currentBaseLayer.setOpacity(opacity);
    });

    const deviceColors = {
      '1': '#E74C3C',   '2': '#3498DB',   '3': '#2ECC71',   '4': '#F39C12',   '5': '#9B59B6',
      '6': '#1ABC9C',   '7': '#E67E22',   '8': '#34495E',   '9': '#E91E63',   '10': '#FF5722',
      '11': '#795548',  '12': '#607D8B',  '13': '#FF9800',  '14': '#4CAF50',  '15': '#673AB7',
      '16': '#FF1744',  '17': '#448AFF',  '18': '#00E676',  '19': '#FFC107',  '20': '#AB47BC',
      '21': '#26C6DA',  '22': '#FF6F00',  '23': '#546E7A',  '24': '#EC407A',  '25': '#8BC34A',
      '26': '#5E35B1',  '27': '#FF5252',  '28': '#00BCD4',  '29': '#FFEB3B',  '30': '#795548',
      'I': '#E74C3C',     'II': '#3498DB',    'III': '#2ECC71',   'IV': '#F39C12',    'V': '#9B59B6',
      'VI': '#1ABC9C',    'VII': '#E67E22',   'VIII': '#34495E',  'IX': '#E91E63',    'X': '#FF5722',
      'XI': '#795548',    'XII': '#607D8B',   'XIII': '#FF9800',  'XIV': '#4CAF50',   'XV': '#673AB7',
      'XVI': '#FF1744',   'XVII': '#448AFF',  'XVIII': '#00E676', 'XIX': '#FFC107',   'XX': '#AB47BC',
      'XXI': '#26C6DA',   'XXII': '#FF6F00',  'XXIII': '#546E7A', 'XXIV': '#EC407A',  'XXV': '#8BC34A',
      'XXVI': '#5E35B1',  'XXVII': '#FF5252', 'XXVIII': '#00BCD4','XXIX': '#FFEB3B',  'XXX': '#795548'
    };

    const socket = io({ 
      transports: ['websocket'],
      timeout: 5000,
      forceNew: true
    });
    
    const socketStatus = document.getElementById('socket-status');
    const deviceCount = document.getElementById('device-count');
    const pointCount = document.getElementById('point-count');
    const rejectedCount = document.getElementById('rejected-count');
    const lastUpdate = document.getElementById('last-update');
    
    let totalPoints = 0;

    socket.on('connect', () => {
      console.log('‚úÖ Socket connected');
      socketStatus.textContent = '‚úÖ';
      socketStatus.style.color = '#2ECC71';
    });

    socket.on('disconnect', () => {
      console.log('‚ùå Socket disconnected');
      socketStatus.textContent = '‚ùå';
      socketStatus.style.color = '#E74C3C';
    });

    socket.on('connect_error', (error) => {
      console.error('Socket connection error:', error);
      socketStatus.textContent = '‚ö†Ô∏è';
      socketStatus.style.color = '#F39C12';
    });

    const gpsTrails = {};
    const packetCounts = {};
    const latestPackets = {};
    const allPointsBounds = L.latLngBounds();
    const allMarkers = {};
    const trailLayers = {};
    const deviceVisibility = {};
    let selectedDevice = null;
    let hasInitialData = false;

    function toggleDeviceVisibility(deviceId) {
      if (selectedDevice === deviceId) {
        selectedDevice = null;
        showAllDevices();
      } else {
        selectedDevice = deviceId;
        hideAllDevicesExcept(deviceId);
      }
    }

    function showAllDevices() {
      Object.keys(allMarkers).forEach(deviceId => {
        deviceVisibility[deviceId] = true;
        showDeviceMarkers(deviceId);
      });
    }

    function hideAllDevicesExcept(keepDeviceId) {
      Object.keys(allMarkers).forEach(deviceId => {
        if (deviceId === keepDeviceId) {
          deviceVisibility[deviceId] = true;
          showDeviceMarkers(deviceId);
        } else {
          deviceVisibility[deviceId] = false;
          hideDeviceMarkers(deviceId);
        }
      });
    }

    function showDeviceMarkers(deviceId) {
      if (allMarkers[deviceId] && allMarkers[deviceId].current) {
        allMarkers[deviceId].current.circle.addTo(map);
        allMarkers[deviceId].current.label.addTo(map);
      }
      
      if (allMarkers[deviceId] && allMarkers[deviceId].history) {
        allMarkers[deviceId].history.forEach(marker => {
          marker.addTo(map);
        });
      }
      
      if (trailLayers[deviceId]) {
        trailLayers[deviceId].forEach(layer => {
          layer.addTo(map);
        });
      }
    }

    function hideDeviceMarkers(deviceId) {
      if (allMarkers[deviceId] && allMarkers[deviceId].current) {
        map.removeLayer(allMarkers[deviceId].current.circle);
        map.removeLayer(allMarkers[deviceId].current.label);
      }
      
      if (allMarkers[deviceId] && allMarkers[deviceId].history) {
        allMarkers[deviceId].history.forEach(marker => {
          map.removeLayer(marker);
        });
      }
      
      if (trailLayers[deviceId]) {
        trailLayers[deviceId].forEach(layer => {
          map.removeLayer(layer);
        });
      }
    }

    function addDataPoint(point, isLatest = false) {
      const lat = parseFloat(point.latitude);
      const lon = parseFloat(point.longitude);
      
      if (isNaN(lat) || isNaN(lon) || lat < -90 || lat > 90 || lon < -180 || lon > 180) {
        console.warn('Invalid coordinates:', point);
        return;
      }

      const color = deviceColors[point.device_id] || "#7F8C8D";
      const gridRef = latLonToGridReference(lat, lon);

      if (isLatest) {
        const circle = L.circleMarker([lat, lon], {
          radius: 10,
          color: color,
          fillColor: color,
          fillOpacity: 0.7,
          weight: 3
        });

        const popupContent = `
          <strong>Device ID:</strong> ${point.device_id}<br>
          <strong>Grid Reference:</strong> ${gridRef}<br>
          <strong>Lat/Lon:</strong> ${lat.toFixed(6)}, ${lon.toFixed(6)}<br>
          <strong>Timestamp:</strong> ${point.timestamp}<br>
          <strong>Satellites:</strong> ${point.sats || 'N/A'}
        `;
        circle.bindPopup(popupContent);

        const label = L.divIcon({
          html: `<div style="color: ${color}; font-weight: bold; text-shadow: 1px 1px 2px white;">${point.device_id}</div>`,
          className: 'device-label',
          iconSize: [20, 20]
        });

        const labelMarker = L.marker([lat, lon], { icon: label, interactive: false });
        
        if (!allMarkers[point.device_id]) allMarkers[point.device_id] = { current: null, history: [] };
        
        if (allMarkers[point.device_id].current) {
          map.removeLayer(allMarkers[point.device_id].current.circle);
          map.removeLayer(allMarkers[point.device_id].current.label);
        }
        
        allMarkers[point.device_id].current = { circle, label: labelMarker };
        
        if (deviceVisibility[point.device_id] !== false) {
          circle.addTo(map);
          labelMarker.addTo(map);
        }
        
        totalPoints++;
        
      } else {
        const isFirstPoint = !allMarkers[point.device_id] || allMarkers[point.device_id].history.length === 0;
        
        if (isFirstPoint) {
          const crestIcon = L.icon({
            iconUrl: "https://raw.githubusercontent.com/AnthonyMacks/gps_tracker/main/templates/scucrest.png",
            iconSize: [32, 32],
            iconAnchor: [16, 32],
            popupAnchor: [0, -32]
          });

          const crestMarker = L.marker([lat, lon], { 
            icon: crestIcon,
            interactive: true
          });

          const popupContent = `
            <strong>Device ID:</strong> ${point.device_id} (START)<br>
            <strong>Grid Reference:</strong> ${gridRef}<br>
            <strong>Lat/Lon:</strong> ${lat.toFixed(6)}, ${lon.toFixed(6)}<br>
            <strong>Timestamp:</strong> ${point.timestamp}
          `;
          crestMarker.bindPopup(popupContent);

          if (!allMarkers[point.device_id]) allMarkers[point.device_id] = { current: null, history: [] };
          allMarkers[point.device_id].history.push(crestMarker);
          
          if (deviceVisibility[point.device_id] !== false) {
            crestMarker.addTo(map);
          }
          
          totalPoints++;
        } else {
          const pinIcon = L.divIcon({
            html: `<div style="
              width: 12px; 
              height: 12px; 
              background-color: ${color}; 
              border: 2px solid white; 
              border-radius: 50%;
              box-shadow: 0 0 3px rgba(0,0,0,0.4);
            "></div>`,
            className: 'history-pin',
            iconSize: [16, 16],
            iconAnchor: [8, 8]
          });

          const pin = L.marker([lat, lon], { 
            icon: pinIcon,
            interactive: true
          });

          const popupContent = `
            <strong>Device ID:</strong> ${point.device_id}<br>
            <strong>Grid Reference:</strong> ${gridRef}<br>
            <strong>Lat/Lon:</strong> ${lat.toFixed(6)}, ${lon.toFixed(6)}<br>
            <strong>Timestamp:</strong> ${point.timestamp}
          `;
          pin.bindPopup(popupContent);

          if (!allMarkers[point.device_id]) allMarkers[point.device_id] = { current: null, history: [] };
          allMarkers[point.device_id].history.push(pin);
          
          if (deviceVisibility[point.device_id] !== false) {
            pin.addTo(map);
          }
          
          totalPoints++;
        }
      }
    }

    function drawTrail(device_id) {
      const trail = gpsTrails[device_id];
      if (!trail || trail.length < 2) return;
      
      const color = deviceColors[device_id] || "#7F8C8D";

      if (trailLayers[device_id]) {
        trailLayers[device_id].forEach(layer => {
          if (map.hasLayer(layer)) {
            map.removeLayer(layer);
          }
        });
      }
      trailLayers[device_id] = [];

      const polyline = L.polyline(trail, {
        color: color,
        weight: 4,
        opacity: 0.8,
        className: 'animated-polyline'
      });
      
      trailLayers[device_id].push(polyline);
      
      if (deviceVisibility[device_id] !== false) {
        polyline.addTo(map);
      }
    }

    function getRowClass(ts, sats) {
      const pingTime = new Date(ts);
      const now = new Date();
      const diff = (now - pingTime) / 1000;

      if (sats !== undefined && sats < 4) return "row-low-sats";

      if (diff <= 180) return "row-active";
      if (diff <= 360) return "row-warm";
      return "row-stale";
    }

    function updateTable() {
      const tbody1 = document.querySelector("#device-table tbody");
      const tbody2 = document.querySelector("#device-table2 tbody");
      tbody1.innerHTML = "";
      tbody2.innerHTML = "";

      const sortedIDs = Object.keys(latestPackets).sort((a, b) =>
        a.localeCompare(b, 'en', { sensitivity: 'base', numeric: true })
      );

      const firstTableDevices = ['I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX', 'X', 'XI', 'XII'];
      const secondTableDevices = ['XIII', 'XIV', 'XV', 'XVI', 'XVII', 'XVIII', 'XIX', 'XX', 'XXI', 'XXII', 'XXIII', 'XXIV', 'XXV', 'XXVI', 'XXVII', 'XXVIII', 'XXIX', 'XXX'];

      for (const id of sortedIDs) {
        const packet = latestPackets[id];
        const count  = packetCounts[id] || 0;
        const sats   = packet.sats ?? "‚Äî";
        const lat    = parseFloat(packet.latitude);
        const lon    = parseFloat(packet.longitude);
        const gridRef = latLonToGridReference(lat, lon);

        const row = document.createElement("tr");
        row.className = getRowClass(packet.timestamp, packet.sats);

        row.innerHTML = `
          <td>${id}</td>
          <td>${gridRef}</td>
          <td>${count}</td>
          <td>${sats}</td>
        `;

        row.style.cursor = "pointer";
        row.addEventListener("click", () => {
          toggleDeviceVisibility(id);
          updateTable();
        });

        if (selectedDevice === id) {
          row.style.border = "2px solid #3498DB";
        }

        if (firstTableDevices.includes(id)) {
          tbody1.appendChild(row);
        } else if (secondTableDevices.includes(id)) {
          tbody2.appendChild(row);
        }
      }
    }

    function updateDebugInfo() {
      deviceCount.textContent = Object.keys(latestPackets).length;
      pointCount.textContent = totalPoints;
      rejectedCount.textContent = rejectedPointsCount;
      lastUpdate.textContent = new Date().toLocaleTimeString();
      updateStoredCount();
    }
    
    function processGPSUpdate(data) {
      console.log('üì° Processing GPS update:', data);
      
      const { latitude, longitude, device_id, timestamp } = data;
      if (!latitude || !longitude || !device_id || !timestamp) {
        console.warn('Missing required data:', data);
        return;
      }

      const lat = parseFloat(latitude);
      const lon = parseFloat(longitude);
      
      if (isNaN(lat) || isNaN(lon)) {
        console.warn('Invalid coordinates:', data);
        return;
      }

      if (!isValidDistance(device_id, lat, lon)) {
        updateDebugInfo();
        return;
      }

      latestPackets[device_id] = {
        ...data,
        timestamp: timestamp.replace(" ", "T") + "Z"
      };

      packetCounts[device_id] = (packetCounts[device_id] || 0) + 1;

      if (gpsTrails[device_id] && gpsTrails[device_id].length) {
        const lastPoint = {
          ...latestPackets[device_id],
          latitude: gpsTrails[device_id][gpsTrails[device_id].length - 1][0],
          longitude: gpsTrails[device_id][gpsTrails[device_id].length - 1][1]
        };
        addDataPoint(lastPoint, false);
      }
      
      addDataPoint(data, true);

      allPointsBounds.extend([lat, lon]);
      
      if (!hasInitialData) {
        map.fitBounds(allPointsBounds, { padding: [30, 30], maxZoom: 16 });
        hasInitialData = true;
      }

      gpsTrails[device_id] = gpsTrails[device_id] || [];
      gpsTrails[device_id].push([lat, lon]);
      if (gpsTrails[device_id].length > 100) gpsTrails[device_id].shift();

      drawTrail(device_id);

      updateTable();
      updateDebugInfo();

      saveToLocalStorage();
    }

    const devicePoints = {};
    
    function exportKML(deviceId) {
      try {
        console.log(`üì• Exporting KML for: ${deviceId}`);
    
        // Check if we have any data at all
        if (Object.keys(deviceStartPoints).length === 0 && Object.keys(gpsTrails).length === 0) {
          alert('‚ö†Ô∏è No GPS data available to export. Wait for devices to connect.');
          return;
        }
    
        let kmlHeader = `<?xml version="1.0" encoding="UTF-8"?>
    <kml xmlns="http://www.opengis.net/kml/2.2">
      <Document>
        <name>GPS MacksTrack Export - ${deviceId === 'all' ? 'All Devices' : 'Device ' + deviceId}</name>
        <description>Exported on ${new Date().toLocaleString('en-AU', {timeZone: 'Australia/Sydney'})}</description>`;

        let kmlFooter = `
      </Document>
    </kml>`;
    
        let placemarks = '';
        let deviceCount = 0;
    
        // Get list of devices to export
        const allDeviceIds = [...new Set([
          ...Object.keys(deviceStartPoints),
          ...Object.keys(gpsTrails)
        ])];
    
        const devices = deviceId === 'all' ? allDeviceIds : [deviceId];
    
        // Check if requested device exists
        if (devices.length === 0 || (deviceId !== 'all' && !allDeviceIds.includes(deviceId))) {
          alert(`‚ö†Ô∏è Device "${deviceId}" has no data to export.`);
          return;
        }
    
        devices.forEach(id => {
          const start = deviceStartPoints[id];
          const trail = gpsTrails[id] || [];
          const color = deviceColors[id] || '#7F8C8D';
      
          // Convert hex color to KML format (aabbggrr)
          const kmlColor = 'ff' + color.slice(5,7) + color.slice(3,5) + color.slice(1,3);
      
          let hasData = false;
      
          // Start point marker  
          if (start) {
            hasData = true;
            placemarks += `
        <Placemark>
          <name>Device ${id} - Start Point</name>
          <description>Starting location for device ${id}</description>
          <Style>
            <IconStyle>
              <Icon>
                <href>http://maps.google.com/mapfiles/kml/paddle/grn-circle.png</href>
              </Icon>
            </IconStyle>
          </Style>
          <Point>
            <coordinates>${start.lon},${start.lat},0</coordinates>
          </Point>
        </Placemark>`;
          }
      
          // Current position (if exists)
          if (latestPackets[id]) {
            hasData = true;
            const latest = latestPackets[id];
            const lat = parseFloat(latest.latitude);
            const lon = parseFloat(latest.longitude);
            const gridRef = latLonToGridReference(lat, lon);
        
            placemarks += `
        <Placemark>
          <name>Device ${id} - Current Position</name>
          <description>
            Grid Reference: ${gridRef}
            Latitude: ${lat.toFixed(6)}
            Longitude: ${lon.toFixed(6)}
            Timestamp: ${latest.timestamp}
            Satellites: ${latest.sats || 'N/A'}
            Packet Count: ${packetCounts[id] || 0}
          </description>
          <Style>
            <IconStyle>
              <Icon>
                <href>http://maps.google.com/mapfiles/kml/paddle/red-circle.png</href>
              </Icon>
            </IconStyle>
          </Style>
          <Point>
            <coordinates>${lon},${lat},0</coordinates>
          </Point>
        </Placemark>`;
          }
      
          // Trail line (convert from [[lat,lon], [lat,lon]] format)
          if (trail.length > 1) {
            hasData = true;
            const coordList = trail.map(point => `${point[1]},${point[0]},0`).join(' ');
            placemarks += `
        <Placemark>
          <name>Device ${id} - Trail</name>
          <description>GPS trail for device ${id} (${trail.length} points)</description>
          <Style>
            <LineStyle>
              <color>${kmlColor}</color>
              <width>3</width>
            </LineStyle>
          </Style>
          <LineString>
            <tessellate>1</tessellate>
            <coordinates>
                ${coordList}
            </coordinates>
          </LineString>
        </Placemark>`;
          }
      
          if (hasData) deviceCount++;
        });
    
        if (deviceCount === 0) {
          alert(`‚ö†Ô∏è No GPS data found for ${deviceId === 'all' ? 'any devices' : 'device ' + deviceId}.`);
          return;
        }
    
        const kmlContent = kmlHeader + placemarks + kmlFooter;
    
        // Create and download file
        const blob = new Blob([kmlContent], { type: 'application/vnd.google-earth.kml+xml' });
        const url = URL.createObjectURL(blob);
    
        const link = document.createElement('a');
        link.href = url;
        const timestamp = new Date().toISOString().slice(0,19).replace(/:/g,'-');
        link.download = `MacksTrack_${deviceId}_${timestamp}.kml`;
    
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    
        // Clean up
        setTimeout(() => URL.revokeObjectURL(url), 100);
    
        console.log(`‚úÖ KML exported: ${deviceCount} device(s), ${placemarks.split('<Placemark>').length - 1} features`);
        alert(`‚úÖ Successfully exported ${deviceCount} device(s)!`);
    
      } catch (error) {
        console.error('‚ùå KML Export Error:', error);
        console.error('Error type:', typeof error);
        console.error('Error details:', {
          message: error?.message,
          name: error?.name,
          stack: error?.stack
        });
    
        let errorMsg = 'Unknown error occurred';
        if (error?.message) {
          errorMsg = error.message;
        } else if (typeof error === 'string') {
          errorMsg = error;
        } else if (error?.toString) {
          errorMsg = error.toString();
        }
    
        alert(`‚ùå Export failed: ${errorMsg}\n\nCheck browser console (F12) for details.`);
      }
    }
    
    function downloadKML(content, filename) {
      const blob = new Blob([content], { type: 'application/vnd.google-earth.kml+xml' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = filename;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
      console.log(`KML exported: ${filename}`);
    }

    // ==================== PLAYBACK MODE ====================

    let playbackState = {
      isActive: false,
      isPlaying: false,
      currentIndex: 0,
      speed: 1,
      intervalId: null,
      allPoints: [],
      startTime: null,
      endTime: null,
      savedTrails: {},
      savedMarkers: {},
      savedCenter: null,
      savedZoom: null
    };

    function togglePlaybackMode() {
      const control = document.getElementById('playback-control');
      const toggleBtn = document.getElementById('playback-toggle');
  
      if (!playbackState.isActive) {
        // Enter playback mode
        if (Object.keys(gpsTrails).length === 0) {
          alert('‚ö†Ô∏è No GPS trails available for playback. Wait for data or load from storage.');
          return;
        }
    
        initializePlayback();
        control.classList.add('active');
        toggleBtn.textContent = 'üî¥ Exit Playback';
        playbackState.isActive = true;
      } else {
        // Exit playback mode
        closePlayback();
      }
    }

    function initializePlayback() {
      console.log('üé¨ Initializing playback mode...');
  
      // Collect all points with timestamps
      playbackState.allPoints = [];
  
      Object.keys(gpsTrails).forEach(deviceId => {
        const trail = gpsTrails[deviceId];
        if (!trail || trail.length === 0) return;
    
        trail.forEach((point, index) => {
          // Estimate timestamp if not available
          const timestamp = latestPackets[deviceId]?.timestamp 
            ? new Date(latestPackets[deviceId].timestamp).getTime() - ((trail.length - 1 - index) * 10000)
            : Date.now() - ((trail.length - 1 - index) * 10000);
      
          playbackState.allPoints.push({
            deviceId: deviceId,
            lat: point[0],
            lon: point[1],
            timestamp: timestamp,
            sats: latestPackets[deviceId]?.sats
          });
        });
      });
  
      // Sort by timestamp
      playbackState.allPoints.sort((a, b) => a.timestamp - b.timestamp);
  
      if (playbackState.allPoints.length === 0) {
        alert('‚ö†Ô∏è No valid points for playback.');
        return;
      }
  
      playbackState.startTime = playbackState.allPoints[0].timestamp;
      playbackState.endTime = playbackState.allPoints[playbackState.allPoints.length - 1].timestamp;
      playbackState.currentIndex = 0;

      // Save current state before clearing
      playbackState.savedCenter = map.getCenter();
      playbackState.savedZoom = map.getZoom();
      playbackState.savedTrails = JSON.parse(JSON.stringify(gpsTrails));
      playbackState.savedMarkers = {...allMarkers};
        
      // Clear current map
      clearMapForPlayback();
  
      // Update UI
      updatePlaybackUI();
  
      console.log(`‚úÖ Loaded ${playbackState.allPoints.length} points for playback`);
      console.log(`Duration: ${formatDuration(playbackState.endTime - playbackState.startTime)}`);
    }

    function clearMapForPlayback() {
      // Remove all markers and trails
      Object.keys(allMarkers).forEach(deviceId => {
        hideDeviceMarkers(deviceId);
      });
  
      // Clear trail layers
      Object.values(trailLayers).forEach(layers => {
        layers.forEach(layer => {
          if (map.hasLayer(layer)) {
            map.removeLayer(layer);
          }
        });
      });
    }

    function togglePlayback() {
      if (!playbackState.isPlaying) {
        startPlayback();
      } else {
        pausePlayback();
      }
    }

    function startPlayback() {
      if (playbackState.currentIndex >= playbackState.allPoints.length) {
        restartPlayback();
        return;
      }
  
      playbackState.isPlaying = true;
      document.getElementById('play-btn').textContent = '‚è∏Ô∏è Pause';
      document.getElementById('play-btn').classList.add('playing');
  
      const baseInterval = 100; // milliseconds between frames
      const interval = baseInterval / playbackState.speed;
  
      playbackState.intervalId = setInterval(() => {
        if (playbackState.currentIndex >= playbackState.allPoints.length) {
          pausePlayback();
          return;
        }
    
        const point = playbackState.allPoints[playbackState.currentIndex];
    
        // Add point to map
        const packet = {
          device_id: point.deviceId,
          latitude: point.lat,
          longitude: point.lon,
          timestamp: new Date(point.timestamp).toISOString(),
          sats: point.sats
        };
    
        addDataPoint(packet, true);
    
        // Update trail
        if (!gpsTrails[point.deviceId]) {
          gpsTrails[point.deviceId] = [];
        }
        gpsTrails[point.deviceId].push([point.lat, point.lon]);
        drawTrail(point.deviceId);
    
        playbackState.currentIndex++;
        updatePlaybackUI();
    
      }, interval);
    }

    function pausePlayback() {
      playbackState.isPlaying = false;
      if (playbackState.intervalId) {
        clearInterval(playbackState.intervalId);
        playbackState.intervalId = null;
      }
      document.getElementById('play-btn').textContent = '‚ñ∂Ô∏è Play';
      document.getElementById('play-btn').classList.remove('playing');
    }

    function restartPlayback() {
      pausePlayback();
      playbackState.currentIndex = 0;
  
      // Clear map
      clearMapForPlayback();
  
      // Reset trails
      Object.keys(gpsTrails).forEach(key => {
        gpsTrails[key] = [];
      });
  
      updatePlaybackUI();
    }

    function changePlaybackSpeed() {
      const select = document.getElementById('playback-speed');
      playbackState.speed = parseFloat(select.value);
  
      // Restart interval if playing
      if (playbackState.isPlaying) {
        pausePlayback();
        startPlayback();
      }
    }

    function seekPlayback(value) {
      const wasPlaying = playbackState.isPlaying;
      pausePlayback();
  
      const targetIndex = Math.floor((value / 100) * playbackState.allPoints.length);
      playbackState.currentIndex = Math.max(0, Math.min(targetIndex, playbackState.allPoints.length));
  
      // Rebuild map up to this point
      clearMapForPlayback();
      Object.keys(gpsTrails).forEach(key => {
        gpsTrails[key] = [];
      });
  
      for (let i = 0; i < playbackState.currentIndex; i++) {
        const point = playbackState.allPoints[i];
        if (!gpsTrails[point.deviceId]) {
          gpsTrails[point.deviceId] = [];
        }
        gpsTrails[point.deviceId].push([point.lat, point.lon]);
      }
  
      Object.keys(gpsTrails).forEach(deviceId => {
        if (gpsTrails[deviceId].length > 0) {
          const lastPoint = gpsTrails[deviceId][gpsTrails[deviceId].length - 1];
          const packet = {
            device_id: deviceId,
            latitude: lastPoint[0],
            longitude: lastPoint[1],
            timestamp: new Date().toISOString(),
            sats: latestPackets[deviceId]?.sats
          };
          addDataPoint(packet, true);
          drawTrail(deviceId);
        }
      });
  
      updatePlaybackUI();
  
      if (wasPlaying) {
        startPlayback();
      }
    }

    function updatePlaybackUI() {
      if (playbackState.allPoints.length === 0) return;
  
      const currentPoint = playbackState.allPoints[playbackState.currentIndex];
      const currentTime = currentPoint ? currentPoint.timestamp : playbackState.startTime;
  
      const elapsed = currentTime - playbackState.startTime;
      const total = playbackState.endTime - playbackState.startTime;
  
      const progress = (playbackState.currentIndex / playbackState.allPoints.length) * 100;
  
      document.getElementById('playback-slider').value = progress;
      document.getElementById('playback-time').textContent = 
        `${formatDuration(elapsed)} / ${formatDuration(total)}`;
    }

    function formatDuration(ms) {
      const seconds = Math.floor(ms / 1000);
      const hours = Math.floor(seconds / 3600);
      const minutes = Math.floor((seconds % 3600) / 60);
      const secs = seconds % 60;
  
      return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
    }

    function closePlayback() {
      pausePlayback();
  
      const control = document.getElementById('playback-control');
      const toggleBtn = document.getElementById('playback-toggle');
  
      control.classList.remove('active');
      toggleBtn.textContent = '‚ñ∂Ô∏è Playback Mode';
      playbackState.isActive = false;
  
      // Clear playback visualization
      clearMapForPlayback();
  
      // Restore saved trails
      if (playbackState.savedTrails && Object.keys(playbackState.savedTrails).length > 0) {
        Object.keys(gpsTrails).forEach(key => delete gpsTrails[key]);
        Object.assign(gpsTrails, JSON.parse(JSON.stringify(playbackState.savedTrails)));
    
        // Redraw everything
        Object.keys(gpsTrails).forEach(deviceId => {
          const trail = gpsTrails[deviceId];
          if (trail && trail.length > 0) {
            // Draw all points
            trail.forEach((point, index) => {
              const isLast = index === trail.length - 1;
              const packet = {
                device_id: deviceId,
                latitude: point[0],
                longitude: point[1],
                timestamp: latestPackets[deviceId]?.timestamp || new Date().toISOString(),
                sats: latestPackets[deviceId]?.sats
              };
              addDataPoint(packet, isLast);
            });
        
            drawTrail(deviceId);
          }
        });
    
        // Restore map view
        if (playbackState.savedCenter && playbackState.savedZoom) {
          setTimeout(() => {
            map.setView(playbackState.savedCenter, playbackState.savedZoom);
          }, 100);
        }
      } else {
        // No saved data, just ensure map is visible
        setTimeout(() => {
          map.setView([-33.4452, 150.1528], 15);
        }, 100);
      }
  
      updateTable();
      updateDebugInfo();
  
      console.log('üé¨ Playback mode closed - restored to previous state');
    }

    // Connect toggle button
    document.addEventListener('DOMContentLoaded', function() {
      const toggleBtn = document.getElementById('playback-toggle');
      if (toggleBtn) {
        toggleBtn.addEventListener('click', togglePlaybackMode);
      }
    });
    
    
    console.log('Initializing GPS tracker...');
    
    const hasStoredData = loadFromLocalStorage();
    
    makeDraggable(document.getElementById('info'));
    makeDraggable(document.getElementById('info2'));
    
    setTimeout(() => {
      drawGridLines();
    }, 500);
    
    const debugPanel = document.getElementById('debug');
    let debugTimeout;
    
    debugPanel.classList.add('collapsed');
    
    debugPanel.addEventListener('mouseenter', () => {
      clearTimeout(debugTimeout);
      debugPanel.classList.remove('collapsed');
    });
    
    debugPanel.addEventListener('mouseleave', () => {
      debugTimeout = setTimeout(() => {
        debugPanel.classList.add('collapsed');
      }, 1500);
    });
    
    debugPanel.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      clearTimeout(debugTimeout);
      
      if (debugPanel.classList.contains('collapsed')) {
        debugPanel.classList.remove('collapsed');
        debugTimeout = setTimeout(() => {
          debugPanel.classList.add('collapsed');
        }, 4000);
      } else {
        debugPanel.classList.add('collapsed');
      }
    });
    
    socket.on("gps_update", (data) => {
      processGPSUpdate(data);
    });

    setInterval(updateTable, 10000);
    
    document.getElementById("build-time").textContent =
      new Date().toLocaleString("en-AU", {
        timeZone: "Australia/Sydney",
        hour12: false,
        year: 'numeric',
        month: 'short',
        day: 'numeric',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit'
      });
  </script>
</body>
</html>














