<!DOCTYPE html>
<html>
<head>
  <title>Live GPS Tracker v1.9 - NSW Topo</title>
  <meta charset="utf-8" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <style>
    body, html { margin: 0; padding: 0; height: 100%; }
    #map { height: 100%; width: 100%; z-index: 0; }

    #info {
      position: absolute;
      top: 10px;
      right: 10px;
      max-width: 340px;
      max-height: 70%;
      overflow-y: auto;
      background: rgba(255,255,255,0.85);
      padding: 10px;
      border-radius: 8px;
      font-family: sans-serif;
      font-size: 13px;
      color: #2C3E50;
      box-shadow: 0 0 6px rgba(0,0,0,0.2);
      z-index: 1001;
    }

    .row-active { background-color: #D5F5E3; }
    .row-warm   { background-color: #FCF3CF; }
    .row-stale  { background-color: #FADBD8; }

    .row-low-sats {
      background-color: #F5B7B1 !important;  /* light red */
      animation: blink 1s step-start infinite;
    }

    @keyframes blink {
      50% { background-color: #FADBD8; }
    }

    .device-label {
      background: transparent;
      color: #154360;
      font-weight: bold;
      text-align: center;
      line-height: 24px;
      font-size: 11px;
    }

    .arrow-icon {
      font-weight: bold;
      font-size: 20px;
    }

    footer {
      position: absolute;
      bottom: 10px;
      left: 10px;
      font-size: 12px;
      color: #666;
      font-family: sans-serif;
      background-color: rgba(255,255,255,0.6);
      padding: 4px 8px;
      border-radius: 6px;
      z-index: 1001;
    }

    @keyframes pulse {
      0%   { background-color: #D5F5E3; }
      50%  { background-color: #ABEBC6; }
      100% { background-color: #D5F5E3; }
    }

    .row-active {
      animation: pulse 2s infinite;
    }
    
  </style>
</head>
<body>
  <div id="map"></div>
  <div id="info">
    <strong>📡 Latest GPS Data</strong>
    <table id="device-table">
      <thead>
        <tr>
          <th>ID</th>
          <th>Lat</th>
          <th>Lon</th>
          <th>Count</th>
          <th>Sats</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
  </div>
  <footer>
    🚀 Last Render Build: <span id="build-time">loading...</span>
  </footer>
  
  <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script src="https://unpkg.com/esri-leaflet@3.0.10/dist/esri-leaflet.js"></script>
  <script>
    const map = L.map("map").setView([-33.87, 151.21], 13);
    
    // Base layers
    const osmLayer = L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      maxZoom: 19,
      attribution: "© OpenStreetMap contributors"
    });

    const nswTopoLayer = L.esri.tiledMapLayer({
      url: 'https://maps.six.nsw.gov.au/arcgis/rest/services/public/NSW_Topo_Map/MapServer',
      attribution: '© NSW Spatial Services'
    });

    const nswImageryLayer = L.esri.tiledMapLayer({
      url: 'https://maps.six.nsw.gov.au/arcgis/rest/services/public/NSW_Imagery/MapServer',
      attribution: '© NSW Spatial Services'
    });

    // Add NSW Topo as default
    nswTopoLayer.addTo(map);

    // Layer control
    const baseLayers = {
      "NSW Topographic": nswTopoLayer,
      "NSW Imagery": nswImageryLayer,
      "OpenStreetMap": osmLayer
    };

    L.control.layers(baseLayers, null, {
      position: 'topleft'
    }).addTo(map);

    const socket = io({ transports: ['websocket'] });
    const gpsTrails = {};
    const packetCounts = {};
    const latestPackets = {};
    const allPointsBounds = L.latLngBounds();
    const allMarkers = {}; // Store all markers for each device
    const trailLayers = {}; // Store trail polylines and arrows for cleanup
    const deviceVisibility = {}; // Track which devices are visible
    let selectedDevice = null; // Track which device is selected (if any)

    function toggleDeviceVisibility(deviceId) {
      if (selectedDevice === deviceId) {
        // Clicking on the same device - show all devices
        selectedDevice = null;
        showAllDevices();
      } else {
        // Clicking on a different device - hide all others
        selectedDevice = deviceId;
        hideAllDevicesExcept(deviceId);
      }
    }

    function showAllDevices() {
      Object.keys(allMarkers).forEach(deviceId => {
        deviceVisibility[deviceId] = true;
        showDeviceMarkers(deviceId);
      });
    }

    function hideAllDevicesExcept(keepDeviceId) {
      Object.keys(allMarkers).forEach(deviceId => {
        if (deviceId === keepDeviceId) {
          deviceVisibility[deviceId] = true;
          showDeviceMarkers(deviceId);
        } else {
          deviceVisibility[deviceId] = false;
          hideDeviceMarkers(deviceId);
        }
      });
    }

    function showDeviceMarkers(deviceId) {
      // Show current position markers
      if (allMarkers[deviceId] && allMarkers[deviceId].current) {
        allMarkers[deviceId].current.circle.addTo(map);
        allMarkers[deviceId].current.label.addTo(map);
      }
      
      // Show historical markers
      if (allMarkers[deviceId] && allMarkers[deviceId].history) {
        allMarkers[deviceId].history.forEach(marker => {
          marker.addTo(map);
        });
      }
      
      // Show trail layers
      if (trailLayers[deviceId]) {
        trailLayers[deviceId].forEach(layer => {
          layer.addTo(map);
        });
      }
    }

    function hideDeviceMarkers(deviceId) {
      // Hide current position markers
      if (allMarkers[deviceId] && allMarkers[deviceId].current) {
        map.removeLayer(allMarkers[deviceId].current.circle);
        map.removeLayer(allMarkers[deviceId].current.label);
      }
      
      // Hide historical markers
      if (allMarkers[deviceId] && allMarkers[deviceId].history) {
        allMarkers[deviceId].history.forEach(marker => {
          map.removeLayer(marker);
        });
      }
      
      // Hide trail layers
      if (trailLayers[deviceId]) {
        trailLayers[deviceId].forEach(layer => {
          map.removeLayer(layer);
        });
      }
    }

    function addDataPoint(point, isLatest = false) {
      const lat = parseFloat(point.latitude);
      const lon = parseFloat(point.longitude);
      const color = deviceColors[point.device_id] || "#7F8C8D";

      if (isLatest) {
        // Current position - use larger circle with label
        const circle = L.circleMarker([lat, lon], {
          radius: 12,
          color: color,
          fillColor: color,
          fillOpacity: 0.9,
          weight: 2
        }).addTo(map);

        const popupContent = `
          <strong>Device ID:</strong> ${point.device_id}<br>
          <strong>Latitude:</strong> ${lat.toFixed(6)}<br>
          <strong>Longitude:</strong> ${lon.toFixed(6)}<br>
          <strong>Timestamp:</strong> ${point.timestamp}
        `;
        circle.bindPopup(popupContent);

        const label = L.divIcon({
          html: `<div>${point.device_id}</div>`,
          className: 'device-label',
          iconSize: [24, 24]
        });

        const labelMarker = L.marker([lat, lon], { icon: label, interactive: false }).addTo(map);
        
        // Store current position markers
        if (!allMarkers[point.device_id]) allMarkers[point.device_id] = { current: null, history: [] };
        
        // Remove previous current position markers
        if (allMarkers[point.device_id].current) {
          allMarkers[point.device_id].current.circle.remove();
          allMarkers[point.device_id].current.label.remove();
        }
        
        allMarkers[point.device_id].current = { circle, label: labelMarker };
      } else {
        // Check if this is the first point for this device
        const isFirstPoint = !allMarkers[point.device_id] || allMarkers[point.device_id].history.length === 0;
        
        if (isFirstPoint) {
          // First point - use triangle (same size as current position circle)
          const triangleIcon = L.divIcon({
            html: `<div style="
              width: 0; 
              height: 0; 
              border-left: 12px solid transparent;
              border-right: 12px solid transparent;
              border-bottom: 20px solid ${color};
              filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
            "></div>`,
            className: 'start-triangle',
            iconSize: [24, 20],
            iconAnchor: [12, 20]
          });

          const triangle = L.marker([lat, lon], { 
            icon: triangleIcon,
            interactive: true
          }).addTo(map);

          const popupContent = `
            <strong>Device ID:</strong> ${point.device_id} (START)<br>
            <strong>Latitude:</strong> ${lat.toFixed(6)}<br>
            <strong>Longitude:</strong> ${lon.toFixed(6)}<br>
            <strong>Timestamp:</strong> ${point.timestamp}
          `;
          triangle.bindPopup(popupContent);

          // Store first point marker
          if (!allMarkers[point.device_id]) allMarkers[point.device_id] = { current: null, history: [] };
          allMarkers[point.device_id].history.push(triangle);
        } else {
          // Historical position - use smaller pin
          const pinIcon = L.divIcon({
            html: `<div style="
              width: 6px; 
              height: 6px; 
              background-color: ${color}; 
              border: 1px solid white; 
              border-radius: 50%;
              box-shadow: 0 0 2px rgba(0,0,0,0.3);
            "></div>`,
            className: 'history-pin',
            iconSize: [6, 6],
            iconAnchor: [3, 3]
          });

          const pin = L.marker([lat, lon], { 
            icon: pinIcon,
            interactive: true
          }).addTo(map);

          const popupContent = `
            <strong>Device ID:</strong> ${point.device_id}<br>
            <strong>Latitude:</strong> ${lat.toFixed(6)}<br>
            <strong>Longitude:</strong> ${lon.toFixed(6)}<br>
            <strong>Timestamp:</strong> ${point.timestamp}
          `;
          pin.bindPopup(popupContent);

          // Store historical markers
          if (!allMarkers[point.device_id]) allMarkers[point.device_id] = { current: null, history: [] };
          allMarkers[point.device_id].history.push(pin);
        }
      }
    }

    function calculateBearing(lat1, lon1, lat2, lon2) {
      const dLon = (lon2 - lon1) * Math.PI / 180;
      const lat1Rad = lat1 * Math.PI / 180;
      const lat2Rad = lat2 * Math.PI / 180;
      
      const y = Math.sin(dLon) * Math.cos(lat2Rad);
      const x = Math.cos(lat1Rad) * Math.sin(lat2Rad) - Math.sin(lat1Rad) * Math.cos(lat2Rad) * Math.cos(dLon);
      
      const bearing = Math.atan2(y, x) * 180 / Math.PI;
      return (bearing + 360) % 360; // Normalize to 0-360
    }

    function addArrowToSegment(p1, p2, color) {
      // Calculate midpoint
      const midLat = (p1[0] + p2[0]) / 2;
      const midLon = (p1[1] + p2[1]) / 2;
      
      // Calculate bearing (direction from p1 to p2)
      const bearing = calculateBearing(p1[0], p1[1], p2[0], p2[1]);
      
      // Create arrow as a simple triangle pointing in the direction of travel
      const arrowSvg = `
        <svg width="16" height="16" viewBox="0 0 16 16">
          <polygon points="8,2 12,10 8,8 4,10" fill="${color}" stroke="white" stroke-width="0.5" 
            transform="rotate(${bearing} 8 8)"/>
        </svg>
      `;

      const arrowIcon = L.divIcon({
        html: arrowSvg,
        className: 'arrow-icon',
        iconSize: [16, 16],
        iconAnchor: [8, 8]
      });

      return L.marker([midLat, midLon], { icon: arrowIcon, interactive: false });
    }

    function drawTrail(device_id) {
      const trail = gpsTrails[device_id];
      if (trail.length < 2) return;
      
      const color = deviceColors[device_id] || "#7F8C8D";

      // Clear existing trail layers for this device
      if (trailLayers[device_id]) {
        trailLayers[device_id].forEach(layer => map.removeLayer(layer));
      }
      trailLayers[device_id] = [];

      // Draw polyline
      const polyline = L.polyline(trail, {
        color: color,
        weight: 3,
        opacity: 0.7
      }).addTo(map);
      
      trailLayers[device_id].push(polyline);

      // Add arrows to multiple segments for better direction indication
      const numArrows = Math.min(trail.length - 1, 8); // Max 8 arrows
      const step = Math.max(1, Math.floor((trail.length - 1) / numArrows));
      
      for (let i = step; i < trail.length; i += step) {
        const arrow = addArrowToSegment(trail[i-1], trail[i], color);
        arrow.addTo(map);
        trailLayers[device_id].push(arrow);
      }

      // Always ensure we have an arrow on the most recent segment if it wasn't already covered
      const lastIndex = trail.length - 1;
      if (lastIndex > 0 && (lastIndex % step !== 0)) {
        const lastArrow = addArrowToSegment(trail[lastIndex - 1], trail[lastIndex], color);
        lastArrow.addTo(map);
        trailLayers[device_id].push(lastArrow);
      }
    }

    function getAgeLabel(ts) {
      // turn "YYYY-MM-DD HH:MM:SS" into a real ISO string
      const iso = ts.replace(" ", "T") + "Z";
      const pingTime = new Date(iso);
      if (isNaN(pingTime)) {
        console.warn("Bad timestamp:", ts);
        return "––";
      }

      const nowSec = Date.now();
      const diffSec = Math.floor((nowSec - pingTime.getTime()) / 1000);
      if (diffSec < 60)   return `${diffSec}s ago`;
      if (diffSec < 3600) return `${Math.floor(diffSec/60)}m ago`;
      return `${Math.floor(diffSec/3600)}h ago`;
    }

    function getRowClass(ts, sats) {
      const pingTime = new Date(ts);
      const now = new Date();
      const diff = (now - pingTime) / 1000;

      if (sats !== undefined && sats < 4) return "row-low-sats";

      if (diff <= 180) return "row-active";
      if (diff <= 360) return "row-warm";
      return "row-stale";
    }

    function updateTable() {
      const tbody = document.querySelector("#device-table tbody");
      tbody.innerHTML = "";

      // Sort device IDs naturally (I, II, III… 10, 11…)
      const sortedIDs = Object.keys(latestPackets).sort((a, b) =>
        a.localeCompare(b, 'en', { sensitivity: 'base', numeric: true })
      );

      for (const id of sortedIDs) {
        const packet = latestPackets[id];
        const count  = packetCounts[id] || 0;
        const sats   = packet.sats ?? "—";
        const lat    = parseFloat(packet.latitude).toFixed(6);
        const lon    = parseFloat(packet.longitude).toFixed(6);

        // Create row and apply your coloring logic
        const row = document.createElement("tr");
        row.className = getRowClass(packet.timestamp, packet.sats);

        // Populate cells: ID | Lat | Lon | Count | Sats
        row.innerHTML = `
          <td>${id}</td>
          <td>${lat}</td>
          <td>${lon}</td>
          <td>${count}</td>
          <td>${sats}</td>
        `;

        // Center map on click
        row.addEventListener("click", () => {
          map.setView([lat, lon], 16, { animate: true });
        });

        tbody.appendChild(row);
      }
    }
    
    socket.on("gps_update", (data) => {
      const { latitude, longitude, device_id, timestamp } = data;
      if (!latitude || !longitude || !device_id || !timestamp) return;

      // parse coords and timestamp
      const lat = parseFloat(latitude);
      const lon = parseFloat(longitude);
      // coerce timestamp into ISO so getAgeLabel() works
      latestPackets[device_id] = {
        ...data,
        timestamp: timestamp.replace(" ", "T") + "Z"
      };

      // increment the lowercase count
      packetCounts[device_id] = (packetCounts[device_id] || 0) + 1;

      // move the last "current" point into history
      if (gpsTrails[device_id] && gpsTrails[device_id].length) {
        const lastPoint = {
          ...latestPackets[device_id],
          latitude: gpsTrails[device_id][gpsTrails[device_id].length - 1][0],
          longitude: gpsTrails[device_id][gpsTrails[device_id].length - 1][1]
        };
        addDataPoint(lastPoint, false);
      }
      
      // drop the new current marker
      addDataPoint(data, true);

      // update map bounds
      allPointsBounds.extend([lat, lon]);
      map.fitBounds(allPointsBounds, { padding: [20, 20] });

      // build the lat‐lon trail
      gpsTrails[device_id] = gpsTrails[device_id] || [];
      gpsTrails[device_id].push([lat, lon]);
      if (gpsTrails[device_id].length > 100) gpsTrails[device_id].shift();

      // redraw trail with arrows
      drawTrail(device_id);

      // refresh the info panel (age & count)
      updateTable();

      console.log(`📍 ${device_id} → (${lat.toFixed(6)}, ${lon.toFixed(6)}) | count=${packetCounts[device_id]}`);
    });

    // 🔁 Refresh age and row color even without new packets
    setInterval(updateTable, 10000);
    
    document.getElementById("build-time").textContent =
      new Date().toLocaleString("en-AU", {
        timeZone: "Australia/Sydney",
        hour12: false,
        year: 'numeric',
        month: 'short',
        day: 'numeric',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit'
      });
  </script>
</body>
</html>
